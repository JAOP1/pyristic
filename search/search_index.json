{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00a1Bienvenido a Pyristic! Librer\u00eda de metaheur\u00edsticas para resolver problemas de optimizaci\u00f3n mono-objetivo con o sin restricciones en el lenguaje de python. Los fundamentos de pyristic es proporcionar una accesibilidad para cualquier desarrollador con conocimiento en el \u00e1rea de optimizaci\u00f3n. Para iniciar es necesario instalar pyristic. Recomendamos crear un entorno de conda como sigue: 1 2 3 conda create pyristic-env conda activate pyristic-env pip install pyristic Para comprobar que todo est\u00e1 funcionando correctamente, crea un script de python pyristicTest.py con el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pyristic.heuristic.EvolutionStrategy_search import EvolutionStrategy from pyristic.utils.test_function import beale_ \"\"\" Declaraci\u00f3n del algoritmo: - Funci\u00f3n objetivo - Lista de restricciones - L\u00edmites del problema - Variables de decisi\u00f3n \"\"\" BealeOptimizer = EvolutionStrategy ( ** beale_ ) \"\"\" Ejecuci\u00f3n de la metaheur\u00edstica con los siguientes par\u00e1metros: - N\u00famero de iteraciones - Poblaci\u00f3n en cada iteraci\u00f3n - Poblaci\u00f3n de individuos generados por iteraci\u00f3n - Mostrar la iteraci\u00f3n en la que se encuentra \"\"\" BealeOptimizer . optimize ( 300 , 80 , 160 , verbose = True ) #Resultados obtenidos por la ejecuci\u00f3n del m\u00e9todo optimize. print ( BealeOptimizer ) Si todo funciona correctamente es momento de conocer como est\u00e1 estructurada la librer\u00eda. Actualmente, se encuentran todos los algoritmos en heuristic y todas las utilidades en utils (funciones prueba, clases para almacenar las configuraciones y los operadores para las metaheur\u00edsticas de c\u00f3mputo evolutivo). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \ud83d\uddc0 Pyristic \u2502 \u2514\u2500\u2500\u2500 \ud83d\uddc0 heuristic \u2502 \u2502 EvolutionStrategy_search \u2502 \u2502 EvolutiveProgramming_search \u2502 \u2502 GeneticAlgorithm_search \u2502 \u2502 SimulatedAnnealing_search \u2502 \u2502 Tabu_search \u2502 \u2514\u2500\u2500\u2500 \ud83d\uddc0 utils \u2502 helpers \u2502 test_function \u2502 \u2514\u2500\u2500\u2500 \ud83d\uddc0 operators \u2502 \u2502 crossover \u2502 \u2502 mutation \u2502 \u2502 selection Te invitamos a revisar los notebooks de cada una de las metaheur\u00edsticas en github .","title":"Inicio"},{"location":"#bienvenido-a-pyristic","text":"Librer\u00eda de metaheur\u00edsticas para resolver problemas de optimizaci\u00f3n mono-objetivo con o sin restricciones en el lenguaje de python. Los fundamentos de pyristic es proporcionar una accesibilidad para cualquier desarrollador con conocimiento en el \u00e1rea de optimizaci\u00f3n. Para iniciar es necesario instalar pyristic. Recomendamos crear un entorno de conda como sigue: 1 2 3 conda create pyristic-env conda activate pyristic-env pip install pyristic Para comprobar que todo est\u00e1 funcionando correctamente, crea un script de python pyristicTest.py con el siguiente c\u00f3digo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pyristic.heuristic.EvolutionStrategy_search import EvolutionStrategy from pyristic.utils.test_function import beale_ \"\"\" Declaraci\u00f3n del algoritmo: - Funci\u00f3n objetivo - Lista de restricciones - L\u00edmites del problema - Variables de decisi\u00f3n \"\"\" BealeOptimizer = EvolutionStrategy ( ** beale_ ) \"\"\" Ejecuci\u00f3n de la metaheur\u00edstica con los siguientes par\u00e1metros: - N\u00famero de iteraciones - Poblaci\u00f3n en cada iteraci\u00f3n - Poblaci\u00f3n de individuos generados por iteraci\u00f3n - Mostrar la iteraci\u00f3n en la que se encuentra \"\"\" BealeOptimizer . optimize ( 300 , 80 , 160 , verbose = True ) #Resultados obtenidos por la ejecuci\u00f3n del m\u00e9todo optimize. print ( BealeOptimizer ) Si todo funciona correctamente es momento de conocer como est\u00e1 estructurada la librer\u00eda. Actualmente, se encuentran todos los algoritmos en heuristic y todas las utilidades en utils (funciones prueba, clases para almacenar las configuraciones y los operadores para las metaheur\u00edsticas de c\u00f3mputo evolutivo). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \ud83d\uddc0 Pyristic \u2502 \u2514\u2500\u2500\u2500 \ud83d\uddc0 heuristic \u2502 \u2502 EvolutionStrategy_search \u2502 \u2502 EvolutiveProgramming_search \u2502 \u2502 GeneticAlgorithm_search \u2502 \u2502 SimulatedAnnealing_search \u2502 \u2502 Tabu_search \u2502 \u2514\u2500\u2500\u2500 \ud83d\uddc0 utils \u2502 helpers \u2502 test_function \u2502 \u2514\u2500\u2500\u2500 \ud83d\uddc0 operators \u2502 \u2502 crossover \u2502 \u2502 mutation \u2502 \u2502 selection Te invitamos a revisar los notebooks de cada una de las metaheur\u00edsticas en github .","title":"\u00a1Bienvenido a Pyristic!"},{"location":"AG/","text":"Algoritmos Gen\u00e9ticos La b\u00fasqueda se importar: 1 from pyristic.heuristic.GeneticAlgorithm_search import Genetic Genetic (clase de la metaheur\u00edstica) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda. best_individual. Mejor individuo encontrado. best_f. Aptitud del mejor individuo. current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. population_size. Tama\u00f1o de la poblaci\u00f3n. parent_population_x. Arreglo bidimensional de numpy. Cada fila representa a un individuo de la poblaci\u00f3n actual y cada columna corresponde a una variable de decisi\u00f3n. offspring_population_x. Arreglo bidimensional de numpy. Cada fila representa a un individuo de la poblaci\u00f3n de hijos y cada columna corresponde a una variable de decisi\u00f3n. parent_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de parent_population_x . offspring_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de offspring_population_x . f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. Bounds. Representa los l\u00edmites definidos para cada una de las variables del problema. Se aceptan las siguientes representaciones: Arreglo de numpy con solo dos componentes num\u00e9ricas, donde, la primera componente es el l\u00edmite inferior y la segunda componente es el l\u00edmite superior. Esto significa que todas las variables de decisi\u00f3n estar\u00e1n definidas para el mismo intervalo. Arreglo bidimensional de numpy con dos arreglos de numpy, donde, el primer arreglo de numpy representa el l\u00edmite inferior para cada variable de decisi\u00f3n, mientras, la segunda componente representa el l\u00edmite superior para cada variable de decisi\u00f3n. Decision_variables. El n\u00famero de variables de decisi\u00f3n del problema. M\u00e9todos _ init _ Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. decision_variables. N\u00famero de variables de decisi\u00f3n. constraints. Lista con las restricciones del problema. Las restricciones deben ser funciones que retornan True o False, dependiendo de si se cumple o no dicha restriccio\u0301n. bounds. L\u00edmites de las variables de decisi\u00f3n (se describe los tipos de datos admisibles en el apartado de variables de la clase con el nombre Bounds). config. Estructura de datos ( GeneticConfig ) con los operadores que se emplear\u00e1n en la b\u00fasqueda. Valor de retorno: Ninguno. optimize. M\u00e9todo principal, realiza la ejecuci\u00f3n de la metaheur\u00edstica. Argumentos: generations. N\u00famero de generaciones (iteraciones de la metaheur\u00edstica). size_population. Tama\u00f1o de la poblaci\u00f3n (n\u00famero de individuos). verbose. Indica si se imprime en qu\u00e9 iteraci\u00f3n se encuentra nuestra b\u00fasqueda. Por defecto, est\u00e1 en True. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Ninguno. * fixer. *Si nuestro individuo al ser evaluado no cumple las restricciones del problema, esta funci\u00f3n auxiliar actualizar\u00e1 nuestro individuo de modo que sea v\u00e1lida. La funci\u00f3n auxiliar es necesario definirla (No tiene ninguna por defecto), se especifica en la configuraci\u00f3n (GeneticConfig) o sobreescribiendo dicha funci\u00f3n. Argumentos: ind. \u00cdndice del individuo. Valor de retorno: Un arreglo de numpy con la soluci\u00f3n factible. initialize_population. Crea una poblacio\u0301n de individuos aleatorios. Para ello se utiliza una distribucio\u0301n uniforme y se generan nu\u0301meros aleatorios dentro de los li\u0301mites indicados para cada variable. Los individuos generados son almacenados en logger con la llave parent_population_x . Esta funcio\u0301n es llamada dentro de la funcio\u0301n optimize . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . Cada fila representa un individuo, cada columna indica los valores para cada variable de decisio\u0301n del individuo. mutation_operator. Muta las variables de decisi\u00f3n de la poblaci\u00f3n de hijos, las cuales se encuentran almacenadas en el diccionario logger con la llave offspring_population_x . El operador de mutaci\u00f3n es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el operador. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con la poblaci\u00f3n mutada. Cada fila representa un individuo y cada columna corresponde a una variable de decisi\u00f3n. crossover_operator. Dada una poblaci\u00f3n de padres, genera una poblaci\u00f3n de hijos aplicando alg\u00fan tipo de cruza. El operador de cruza es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el operador. Argumentos: parent_ind1. \u00cdndices de los individuos que son seleccionados para actuar como padre 1. parent_ind2. \u00cdndices de los individuos que son seleccionados para actuar como padre 2. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con la poblaci\u00f3n generada por la cruza. Cada fila representa un individuo y cada columna corresponde a una variable de decisi\u00f3n. parent_selection. Selecciona a los individuos que actuar\u00e1n padres. El m\u00e9todo de selecci\u00f3n es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el m\u00e9todo. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Regresa un arreglo con los \u00edndices de los individuos seleccionados. Estos \u00edndices corresponden con la variable parent_population_x que est\u00e1 almacenada en el diccionario logger . survivor_selection. Selecci\u00f3n de los individuos que pasar\u00e1n a la siguiente generaci\u00f3n. El m\u00e9todo de selecci\u00f3n de sobrevivientes es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el m\u00e9todo. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un diccionario con las siguientes llaves: parent_population_f. Arreglo de numpy con la aptitud de cada uno de los individuos que pasar\u00e1 a la siguiente generaci\u00f3n. parent_population_x. Arreglo bidimensional de numpy con los individuos que pasar\u00e1n a la siguiente generaci\u00f3n. Configuraci\u00f3n de algoritmos gen\u00e9ticos Se debe importar como sigue: 1 from pyristic.utils.helpers import GeneticConfig GeneticConfig (Configuraci\u00f3n de la metaheur\u00edstica) Variables cross_op. Variable con el operador de cruza. mutation_op. Variable con el operador de mutaci\u00f3n. survivor_selection. Variable con el esquema de selecci\u00f3n que decide cu\u00e1les individuos pasan a la siguiente generacio\u0301n. fixer. Variable con una funci\u00f3n que determina qu\u00e9 hacer con los individuos que no cumplen las restricciones del problema. parent_selector. Variable que almacena el operador de selecci\u00f3n. M\u00e9todos cross. Actualiza el operador de cruza de la variable cross_op . Argumentos: crossover_. Funci\u00f3n o clase que realiza la cruza de la poblaci\u00f3n almacenada con la llave parent_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. mutate. Actualiza el operador de mutaci\u00f3n de la variable mutation_op . Argumentos: mutate_. Funci\u00f3n o clase que realiza la mutaci\u00f3n de la poblaci\u00f3n almacenada con la llave offspring_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. survivor_selection. Actualiza el operador de selecci\u00f3n de la variable survivor_selector . Argumentos: survivor_function. Funci\u00f3n o clase que realiza la selecci\u00f3n de individuos que pasar\u00e1n a la siguiente generaci\u00f3n. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. fixer_invalide_solutions. Actualiza la funci\u00f3n auxiliar de la variable fixer . Argumentos: fixer_function. Funci\u00f3n o clase que ajustar\u00e1 los individuos de la poblaci\u00f3n que no cumplen con las restricciones del problema. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. parent_selection. Actualiza el operador de selecci\u00f3n de los individuos con mayores posibilidades de reproducci\u00f3n, se encuentran en la variable parent_selector . Argumentos: parent_function. Funci\u00f3n o clase que elige los individuos de acuerdo a su contribuci\u00f3n de aptitud. Este m\u00e9todo en la b\u00fasqueda es realizado antes de la cruza. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. Ejemplo Hay varias formas de emplear la metaheur\u00edstica, le sugerimos revisar los ejemplos. A continuaci\u00f3n presentamos un ejemplo de empleo para el problema de ackley_: 1 2 3 4 5 6 7 8 9 10 configuration = ( helpers . GeneticConfig () . cross ( crossover . intermediate_crossover ( 0.5 )) . mutate ( mutation . uniform_mutator ( ackley_ [ 'bounds' ])) . survivor_selection ( selection . merge_selector ()) . parent_selection ( selection . tournament_sampler ( transformer , 3 , 0.5 )) . fixer_invalide_solutions ( helpers . ContinuosFixer ( ackley_ [ 'bounds' ]))) AckleyGenetic = Genetic ( ** ackley_ , config = configuration ) AckleyGenetic . optimize ( 200 , 100 ) print ( AckleyGenetic )","title":"Algoritmos gen\u00e9ticos"},{"location":"AG/#algoritmos-geneticos","text":"La b\u00fasqueda se importar: 1 from pyristic.heuristic.GeneticAlgorithm_search import Genetic Genetic (clase de la metaheur\u00edstica) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda. best_individual. Mejor individuo encontrado. best_f. Aptitud del mejor individuo. current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. population_size. Tama\u00f1o de la poblaci\u00f3n. parent_population_x. Arreglo bidimensional de numpy. Cada fila representa a un individuo de la poblaci\u00f3n actual y cada columna corresponde a una variable de decisi\u00f3n. offspring_population_x. Arreglo bidimensional de numpy. Cada fila representa a un individuo de la poblaci\u00f3n de hijos y cada columna corresponde a una variable de decisi\u00f3n. parent_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de parent_population_x . offspring_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de offspring_population_x . f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. Bounds. Representa los l\u00edmites definidos para cada una de las variables del problema. Se aceptan las siguientes representaciones: Arreglo de numpy con solo dos componentes num\u00e9ricas, donde, la primera componente es el l\u00edmite inferior y la segunda componente es el l\u00edmite superior. Esto significa que todas las variables de decisi\u00f3n estar\u00e1n definidas para el mismo intervalo. Arreglo bidimensional de numpy con dos arreglos de numpy, donde, el primer arreglo de numpy representa el l\u00edmite inferior para cada variable de decisi\u00f3n, mientras, la segunda componente representa el l\u00edmite superior para cada variable de decisi\u00f3n. Decision_variables. El n\u00famero de variables de decisi\u00f3n del problema. M\u00e9todos _ init _ Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. decision_variables. N\u00famero de variables de decisi\u00f3n. constraints. Lista con las restricciones del problema. Las restricciones deben ser funciones que retornan True o False, dependiendo de si se cumple o no dicha restriccio\u0301n. bounds. L\u00edmites de las variables de decisi\u00f3n (se describe los tipos de datos admisibles en el apartado de variables de la clase con el nombre Bounds). config. Estructura de datos ( GeneticConfig ) con los operadores que se emplear\u00e1n en la b\u00fasqueda. Valor de retorno: Ninguno. optimize. M\u00e9todo principal, realiza la ejecuci\u00f3n de la metaheur\u00edstica. Argumentos: generations. N\u00famero de generaciones (iteraciones de la metaheur\u00edstica). size_population. Tama\u00f1o de la poblaci\u00f3n (n\u00famero de individuos). verbose. Indica si se imprime en qu\u00e9 iteraci\u00f3n se encuentra nuestra b\u00fasqueda. Por defecto, est\u00e1 en True. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Ninguno. * fixer. *Si nuestro individuo al ser evaluado no cumple las restricciones del problema, esta funci\u00f3n auxiliar actualizar\u00e1 nuestro individuo de modo que sea v\u00e1lida. La funci\u00f3n auxiliar es necesario definirla (No tiene ninguna por defecto), se especifica en la configuraci\u00f3n (GeneticConfig) o sobreescribiendo dicha funci\u00f3n. Argumentos: ind. \u00cdndice del individuo. Valor de retorno: Un arreglo de numpy con la soluci\u00f3n factible. initialize_population. Crea una poblacio\u0301n de individuos aleatorios. Para ello se utiliza una distribucio\u0301n uniforme y se generan nu\u0301meros aleatorios dentro de los li\u0301mites indicados para cada variable. Los individuos generados son almacenados en logger con la llave parent_population_x . Esta funcio\u0301n es llamada dentro de la funcio\u0301n optimize . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . Cada fila representa un individuo, cada columna indica los valores para cada variable de decisio\u0301n del individuo. mutation_operator. Muta las variables de decisi\u00f3n de la poblaci\u00f3n de hijos, las cuales se encuentran almacenadas en el diccionario logger con la llave offspring_population_x . El operador de mutaci\u00f3n es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el operador. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con la poblaci\u00f3n mutada. Cada fila representa un individuo y cada columna corresponde a una variable de decisi\u00f3n. crossover_operator. Dada una poblaci\u00f3n de padres, genera una poblaci\u00f3n de hijos aplicando alg\u00fan tipo de cruza. El operador de cruza es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el operador. Argumentos: parent_ind1. \u00cdndices de los individuos que son seleccionados para actuar como padre 1. parent_ind2. \u00cdndices de los individuos que son seleccionados para actuar como padre 2. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con la poblaci\u00f3n generada por la cruza. Cada fila representa un individuo y cada columna corresponde a una variable de decisi\u00f3n. parent_selection. Selecciona a los individuos que actuar\u00e1n padres. El m\u00e9todo de selecci\u00f3n es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el m\u00e9todo. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Regresa un arreglo con los \u00edndices de los individuos seleccionados. Estos \u00edndices corresponden con la variable parent_population_x que est\u00e1 almacenada en el diccionario logger . survivor_selection. Selecci\u00f3n de los individuos que pasar\u00e1n a la siguiente generaci\u00f3n. El m\u00e9todo de selecci\u00f3n de sobrevivientes es necesario definirlo (No tiene ning\u00fan operador por defecto), se especifica en la configuraci\u00f3n ( GeneticConfig ) o sobreescribiendo el m\u00e9todo. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un diccionario con las siguientes llaves: parent_population_f. Arreglo de numpy con la aptitud de cada uno de los individuos que pasar\u00e1 a la siguiente generaci\u00f3n. parent_population_x. Arreglo bidimensional de numpy con los individuos que pasar\u00e1n a la siguiente generaci\u00f3n.","title":"Algoritmos Gen\u00e9ticos"},{"location":"AG/#configuracion-de-algoritmos-geneticos","text":"Se debe importar como sigue: 1 from pyristic.utils.helpers import GeneticConfig GeneticConfig (Configuraci\u00f3n de la metaheur\u00edstica) Variables cross_op. Variable con el operador de cruza. mutation_op. Variable con el operador de mutaci\u00f3n. survivor_selection. Variable con el esquema de selecci\u00f3n que decide cu\u00e1les individuos pasan a la siguiente generacio\u0301n. fixer. Variable con una funci\u00f3n que determina qu\u00e9 hacer con los individuos que no cumplen las restricciones del problema. parent_selector. Variable que almacena el operador de selecci\u00f3n. M\u00e9todos cross. Actualiza el operador de cruza de la variable cross_op . Argumentos: crossover_. Funci\u00f3n o clase que realiza la cruza de la poblaci\u00f3n almacenada con la llave parent_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. mutate. Actualiza el operador de mutaci\u00f3n de la variable mutation_op . Argumentos: mutate_. Funci\u00f3n o clase que realiza la mutaci\u00f3n de la poblaci\u00f3n almacenada con la llave offspring_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. survivor_selection. Actualiza el operador de selecci\u00f3n de la variable survivor_selector . Argumentos: survivor_function. Funci\u00f3n o clase que realiza la selecci\u00f3n de individuos que pasar\u00e1n a la siguiente generaci\u00f3n. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. fixer_invalide_solutions. Actualiza la funci\u00f3n auxiliar de la variable fixer . Argumentos: fixer_function. Funci\u00f3n o clase que ajustar\u00e1 los individuos de la poblaci\u00f3n que no cumplen con las restricciones del problema. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. parent_selection. Actualiza el operador de selecci\u00f3n de los individuos con mayores posibilidades de reproducci\u00f3n, se encuentran en la variable parent_selector . Argumentos: parent_function. Funci\u00f3n o clase que elige los individuos de acuerdo a su contribuci\u00f3n de aptitud. Este m\u00e9todo en la b\u00fasqueda es realizado antes de la cruza. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada.","title":"Configuraci\u00f3n de algoritmos gen\u00e9ticos"},{"location":"AG/#ejemplo","text":"Hay varias formas de emplear la metaheur\u00edstica, le sugerimos revisar los ejemplos. A continuaci\u00f3n presentamos un ejemplo de empleo para el problema de ackley_: 1 2 3 4 5 6 7 8 9 10 configuration = ( helpers . GeneticConfig () . cross ( crossover . intermediate_crossover ( 0.5 )) . mutate ( mutation . uniform_mutator ( ackley_ [ 'bounds' ])) . survivor_selection ( selection . merge_selector ()) . parent_selection ( selection . tournament_sampler ( transformer , 3 , 0.5 )) . fixer_invalide_solutions ( helpers . ContinuosFixer ( ackley_ [ 'bounds' ]))) AckleyGenetic = Genetic ( ** ackley_ , config = configuration ) AckleyGenetic . optimize ( 200 , 100 ) print ( AckleyGenetic )","title":"Ejemplo"},{"location":"Agradecimientos/","text":"","title":"Desarrolladores"},{"location":"EE/","text":"Estrategias evolutivas La b\u00fasqueda se importar: 1 from pyristic.heuristic.EvolutionStrategy_search import EvolutionStrategy EvolutionStrategy (clase de la metaheur\u00edstica) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda. best_individual. Individuo con el mejor valor encontrado en la funci\u00f3n objetivo. best_f. Valor de la funci\u00f3n objetivo. current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. parent_population_size. Tama\u00f1o de la poblaci\u00f3n de padres. offspring_population_size. Tama\u00f1o de la poblaci\u00f3n de hijos. parent_population_x. Arreglo bidimensional de numpy . Cada fila representa un individuo de la poblaci\u00f3n actual y cada columna corresponde a una variable de decisi\u00f3n. offspring_population_x. Arreglo bidimensional de numpy . Cada fila representa un individuo de la poblaci\u00f3n de hijos y cada columna corresponde a una variable de decisi\u00f3n. parent_population_sigma. Arreglo de numpy , donde, cada elemento representa el desplazamiento de todas las variables de decisi\u00f3n de cada individuo o un arreglo bidimensional de numpy , donde, cada fila representa el desplazamiento de cada una de las variables de decisi\u00f3n de un individuo. offspring_population_sigma. Arreglo de numpy , donde, cada elemento representa el desplazamiento de todas las variables de decisi\u00f3n de un individuo o un arreglo bidimensional de numpy , donde, cada fila representa el desplazamiento de cada una de las variables de decisi\u00f3n de un individuo. parent_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n con la llave parent_population_x en logger . offspring_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n con la llave offspring_population_x . f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. Bounds. Representa los l\u00edmites definidos para cada una de las variables del problema. Se aceptan las siguientes representaciones: Arreglo de numpy con solo dos componentes num\u00e9ricas, donde, la primera componente es el l\u00edmite inferior y la segunda componente es el l\u00edmite superior. Esto significa que todas las variables de decisi\u00f3n estar\u00e1n definidas para el mismo intervalo. Arreglo bidimensional de numpy con \u00fanicamente dos filas, donde, la primer fila es el l\u00edmite inferior para cada variable de decisi\u00f3n, mientras, la segunda fila representa el l\u00edmite superior para cada variable de decisi\u00f3n. Decision_variables. El n\u00famero de variables de decisi\u00f3n del problema. M\u00e9todos __init__. Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. decision_variables. N\u00famero de variables de decisi\u00f3n del problema. constraints. Lista con las restricciones del problema (se describe los tipos de datos admisibles en el apartado de variables de la clase con el nombre Constraints ). bounds. L\u00edmites de las variables de decisi\u00f3n (se describe los tipos de datos admisibles en el apartado de variables de la clase con el nombre Bounds ). config. Estructura de datos ( EvolutionStrategyConfig ) con los operadores que se emplear\u00e1n en la b\u00fasqueda. Valor de retorno: Ninguno. optimize. M\u00e9todo principal, realiza la ejecuci\u00f3n de la metaheur\u00edstica. Argumentos: generations. N\u00famero de generaciones (iteraciones de la metaheur\u00edstica). population_size. Tama\u00f1o de la poblaci\u00f3n (n\u00famero de individuos). offspring_size. Tama\u00f1o de la poblaci\u00f3n creada a partir de los operadores de cruza y mutaci\u00f3n. eps_sigma. Valor m\u00ednimo que pueden tener los tama\u00f1os de paso. Por defecto, est\u00e1 en 0.001. verbose. Indica si se imprime en qu\u00e9 iteraci\u00f3n se encuentra nuestra b\u00fasqueda. Por defecto, est\u00e1 en True. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Ninguno. fixer . Si la soluci\u00f3n no est\u00e1 dentro de los l\u00edmites definidos para cada variable (restricciones de caja), actualiza el valor de la variable con el valor del l\u00edmite que rebas\u00f3. De lo contrario, regresa la misma soluci\u00f3n. Argumentos: ind. \u00cdndice del individuo. Valor de retorno: Un arreglo de numpy que reemplazar\u00e1 la soluci\u00f3n infactible. initialize_population . Crea una poblaci\u00f3n de individuos aleatorios. Para ello se utiliza una distribuci\u00f3n uniforme y se generan n\u00fameros aleatorios dentro de los l\u00edmites indicados para cada variable. Los individuos generados son almacenados en logger con la llave parent_population_x . Esta funci\u00f3n es llamada dentro de la funci\u00f3n optimize . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . Cada fila representa un individuo, cada columna indica los valores para cada variable de decisi\u00f3n del individuo. initialize_step_weights . Inicializa el tama\u00f1o de desplazamiento de cada individuo de la poblaci\u00f3n, por defecto se emplea un sigma por cada variable de decisi\u00f3n en cada uno de los individuos. Para ello se generan n\u00fameros aleatorios en el intervalo \\([0,1]\\) , utilizando una distribuci\u00f3n uniforme. Los tama\u00f1os de desplazamiento est\u00e1n almacenados en logger con la llave parent_population_sigma . Argumentos: eps_sigma. Valor m\u00ednimo que pueden tomar sigma (tama\u00f1os de paso). **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . Cada fila almacena la informaci\u00f3n de los tama\u00f1os de paso de cada individuo, cada columna pertenece al tama\u00f1o de paso de una de las variables de decisi\u00f3n. crossover_operator. Genera \\(\\lambda\\) hijos (individuos nuevos), aplicando una recombinaci\u00f3n sexual. Es decir, se seleccionan dos individuos aleatoriamente de parent_population_x que actuar\u00e1n como padres y generar\u00e1n un hijo. Este procedimiento se repite \\(\\lambda\\) veces. Los nuevos individuos se almacenan en logger con la llave offspring_population_x . Argumentos: parent_ind1. \u00cdndices de los individuos que son seleccionados para actuar como padre 1. parent_ind2. \u00cdndices de los individuos que son seleccionados para actuar como padre 2. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los valores de las variables de decisi\u00f3n de los nuevos individuos. Por defecto la metaheur\u00edstica utiliza el operador de cruza discreta que se encuentra en utils.operators.crossover con el nombre de discrete . mutation_operator. Muta las variables de decisi\u00f3n de los individuos creados con el operador de cruza. Estos individuos est\u00e1n almacenados en el diccionario logger con la llave offspring_population_x . La mutaci\u00f3n se realiza de la siguiente forma por defecto: \\[\\begin{equation} \\label{eq:mutarVariables} x'_i = x_i + \\sigma'_i \\cdot N_i(0, 1) \\end{equation}\\] donde \\(x'_i\\) es la variable mutada, \\(x_i\\) la variable a mutar, \\(\\sigma'_i\\) el tama\u00f1o de paso (previamente mutado) y \\(N_{i}(0,1)\\) devuelve un n\u00famero aleatorio por cada variable de decisi\u00f3n utilizando una distribuci\u00f3n normal con media \\(0\\) y desviaci\u00f3n est\u00e1ndar igual con \\(1\\) . Nota . Es importante tener en cuenta que la fila \\(j\\) de offspring_population_x debe corresponder con la fila \\(j\\) de offspring_population_sigma . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy que almacena los nuevos valores de las variables de decisi\u00f3n. adaptive_crossover. Genera los tama\u00f1os de paso de los nuevos individuos, aplicando una recombinaci\u00f3n sexual. Utiliza las mismas parejas de padres que se usaron con el operador crossover_operator . Los nuevos tama\u00f1os de paso son almacenados en logger con la llave offspring_population_sigma . Argumentos: parent_ind1. \u00cdndices de los individuos que son seleccionados para actuar como padre 1. parent_ind2. \u00cdndices de los individuos que son seleccionados para actuar como padre 2. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los valores de los nuevos tama\u00f1os de paso. Por defecto la metaheur\u00edstica utiliza el operador de cruza intermedia que se encuentra en utils.operators.crossover con el nombre de intermediate . adaptive_mutation. Muta los tama\u00f1os de paso que se encuentran almacenados en el diccionario logger con la llave offspring_population_sigma . Este m\u00e9todo se ejecuta antes del m\u00e9todo mutation_operator . La mutaci\u00f3n se realiza de la siguiente forma por defecto: \\[\\begin{equation*} \\label{eq:mutarNSigmas} \\sigma'_i = \\sigma_i \\cdot e ^ {\\tau' \\cdot N(0,1) + \\tau \\cdot N_i(0,1)} \\end{equation*}\\] Donde, \\(\\sigma_{i}\\) es el tama\u00f1o de paso actual. \\(\\sigma'_{i}\\) es tama\u00f1o de paso mutado. \\(\\tau\\) est\u00e1 definido como \\(\\frac{1}{\\sqrt{2n}}\\) , donde, \\(n\\) es el n\u00famero de variables del problema. \\(\\tau'\\) est\u00e1 definido como \\(\\frac{1}{\\sqrt{2\\sqrt{n}}}\\) , donde, \\(n\\) es el n\u00famero de variables del problema. \\(N(0,1)\\) devuelve un n\u00famero aleatorio usando una distribuci\u00f3n normal con media 0 y desviaci\u00f3n est\u00e1ndar igual a 1. Es importante notar que se genera un \u00fanico n\u00famero aleatorio para todas las \\(\\sigma_{i}\\) . \\(N_{i}(0,1)\\) devuelve un n\u00famero aleatorio por \\(\\sigma_i\\) utilizando una distribuci\u00f3n normal con media 0 y desviaci\u00f3n estandas igual a 1. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los tama\u00f1os de desplazamiento para cada una de las variables de decisi\u00f3n de los individuos. survivor_selection. Selecciona los individuos que formar\u00e1n parte de la siguiente generaci\u00f3n. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un diccionario con las siguientes llaves: parent_population_fitness. El valor de aptitud de cada individuo que pasar\u00e1 a la siguiente generaci\u00f3n. parent_population_sigma. El/los valor(es) de desplazamiento de los individuos seleccionados. parent_population_x. el vector \\(\\vec{x}\\) de cada uno de los individuos. Por defecto la metaheur\u00edstica utiliza el esquema de selecci\u00f3n \\((\\mu + \\lambda)\\) que se encuentra en utils.operators.selection con el nombre de merge_selector . Configuraci\u00f3n de Estrategias evolutivas Se debe importar como sigue: 1 from pyristic.utils.helpers import EvolutionStrategyConfig EvolutionStrategyConfig (Configuraci\u00f3n de la metaheur\u00edstica) Variables cross_op. Variable con el operador de cruza. mutation_op. Variable con el operador de mutaci\u00f3n. survivor_selector. Variable con el esquema de selecci\u00f3n que decide cu\u00e1les individuos pasan a la siguiente generaci\u00f3n. fixer. Variable con una funci\u00f3n que determina qu\u00e9 hacer con los individuos que no cumplen las restricciones del problema. adaptive_crossover_op. Variable con el operador de cruza que se aplica a los tama\u00f1os de paso \\(\\sigma\\) . adaptive_mutation_op. Variable con el operador de mutaci\u00f3n que se aplica a los tama\u00f1os de paso \\(\\sigma\\) . M\u00e9todos cross. Actualiza el operador de cruza de la variable cross_op . Argumentos: crossover_. Funci\u00f3n o clase que realiza la cruza de la poblaci\u00f3n almacenada con la llave parent_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. mutate. Actualiza el operador de mutaci\u00f3n de la variable mutation_op . Argumentos: mutate_. Funci\u00f3n o clase que realiza la mutaci\u00f3n de la poblaci\u00f3n almacenada con la llave offspring_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de mutaci\u00f3n. El objetivo es poder aplicar varios operadores en cascada. survivor_selection. Actualiza el esquema de selecci\u00f3n de la variable survivor_selector . Argumentos: survivor_function. Funci\u00f3n o clase que realiza la selecci\u00f3n de individuos que formar\u00e1n parte de la siguiente generaci\u00f3n. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del esquema de selecci\u00f3n de sobrevivientes. El objetivo es poder aplicar varios operadores en cascada. fixer_invalide_solutions. Actualiza la funci\u00f3n de la variable fixer . Argumentos: fixer_function. Funci\u00f3n o clase que ajustar\u00e1 los individuos de la poblaci\u00f3n que no cumplen con las restricciones del problema. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n de la funci\u00f3n auxiliar. El objetivo es poder aplicar varios operadores en cascada. adaptive_crossover. Actualiza el operador de cruza de los \\(\\sigma\\) de la variable adaptive_crossover_op . Argumentos: adaptive_crossover_function. Funci\u00f3n o clase que cruza los tama\u00f1os de paso de los individuos seleccionados para la cruza. Estos tama\u00f1os de paso est\u00e1n almacenados en el diccionario logger con la llave offspring_population_sigma . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza en los tama\u00f1os de paso. El objetivo es poder aplicar varios operadores en cascada. adaptive_mutation. Actualiza el operador de mutaci\u00f3n de los \\(\\sigma\\) de la variable adaptive_mutation_op . Argumentos: adaptive_mutation_function. Funci\u00f3n o clase que muta los tama\u00f1os de paso que se encuentran en logger con la llave offspring_population_sigma . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de mutaci\u00f3n en los tama\u00f1os de paso. El objetivo es poder aplicar varios operadores en cascada. Ejemplo Hay varias formas de emplear la metaheur\u00edstica, le sugerimos revisar los ejemplos. A continuaci\u00f3n presentamos un ejemplo de empleo para el problema de ackley_: 1 2 3 4 5 6 7 8 9 10 configuration_ackley = ( EvolutionStrategyConfig () . survivor_selection ( selection . replacement_selector ()) . adaptive_mutation ( mutation . single_sigma_adaptive_mutator ( ackley_ [ 'decision_variables' ]) ) ) solver_ackley_custom = EvolutionStrategy ( ** ackley_ , config = configuration_ackley ) solver_ackley_custom . optimize ( 250 , 100 , 200 ) print ( solver_ackley_custom )","title":"Estrategias evolutivas"},{"location":"EE/#estrategias-evolutivas","text":"La b\u00fasqueda se importar: 1 from pyristic.heuristic.EvolutionStrategy_search import EvolutionStrategy EvolutionStrategy (clase de la metaheur\u00edstica) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda. best_individual. Individuo con el mejor valor encontrado en la funci\u00f3n objetivo. best_f. Valor de la funci\u00f3n objetivo. current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. parent_population_size. Tama\u00f1o de la poblaci\u00f3n de padres. offspring_population_size. Tama\u00f1o de la poblaci\u00f3n de hijos. parent_population_x. Arreglo bidimensional de numpy . Cada fila representa un individuo de la poblaci\u00f3n actual y cada columna corresponde a una variable de decisi\u00f3n. offspring_population_x. Arreglo bidimensional de numpy . Cada fila representa un individuo de la poblaci\u00f3n de hijos y cada columna corresponde a una variable de decisi\u00f3n. parent_population_sigma. Arreglo de numpy , donde, cada elemento representa el desplazamiento de todas las variables de decisi\u00f3n de cada individuo o un arreglo bidimensional de numpy , donde, cada fila representa el desplazamiento de cada una de las variables de decisi\u00f3n de un individuo. offspring_population_sigma. Arreglo de numpy , donde, cada elemento representa el desplazamiento de todas las variables de decisi\u00f3n de un individuo o un arreglo bidimensional de numpy , donde, cada fila representa el desplazamiento de cada una de las variables de decisi\u00f3n de un individuo. parent_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n con la llave parent_population_x en logger . offspring_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n con la llave offspring_population_x . f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. Bounds. Representa los l\u00edmites definidos para cada una de las variables del problema. Se aceptan las siguientes representaciones: Arreglo de numpy con solo dos componentes num\u00e9ricas, donde, la primera componente es el l\u00edmite inferior y la segunda componente es el l\u00edmite superior. Esto significa que todas las variables de decisi\u00f3n estar\u00e1n definidas para el mismo intervalo. Arreglo bidimensional de numpy con \u00fanicamente dos filas, donde, la primer fila es el l\u00edmite inferior para cada variable de decisi\u00f3n, mientras, la segunda fila representa el l\u00edmite superior para cada variable de decisi\u00f3n. Decision_variables. El n\u00famero de variables de decisi\u00f3n del problema. M\u00e9todos __init__. Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. decision_variables. N\u00famero de variables de decisi\u00f3n del problema. constraints. Lista con las restricciones del problema (se describe los tipos de datos admisibles en el apartado de variables de la clase con el nombre Constraints ). bounds. L\u00edmites de las variables de decisi\u00f3n (se describe los tipos de datos admisibles en el apartado de variables de la clase con el nombre Bounds ). config. Estructura de datos ( EvolutionStrategyConfig ) con los operadores que se emplear\u00e1n en la b\u00fasqueda. Valor de retorno: Ninguno. optimize. M\u00e9todo principal, realiza la ejecuci\u00f3n de la metaheur\u00edstica. Argumentos: generations. N\u00famero de generaciones (iteraciones de la metaheur\u00edstica). population_size. Tama\u00f1o de la poblaci\u00f3n (n\u00famero de individuos). offspring_size. Tama\u00f1o de la poblaci\u00f3n creada a partir de los operadores de cruza y mutaci\u00f3n. eps_sigma. Valor m\u00ednimo que pueden tener los tama\u00f1os de paso. Por defecto, est\u00e1 en 0.001. verbose. Indica si se imprime en qu\u00e9 iteraci\u00f3n se encuentra nuestra b\u00fasqueda. Por defecto, est\u00e1 en True. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Ninguno. fixer . Si la soluci\u00f3n no est\u00e1 dentro de los l\u00edmites definidos para cada variable (restricciones de caja), actualiza el valor de la variable con el valor del l\u00edmite que rebas\u00f3. De lo contrario, regresa la misma soluci\u00f3n. Argumentos: ind. \u00cdndice del individuo. Valor de retorno: Un arreglo de numpy que reemplazar\u00e1 la soluci\u00f3n infactible. initialize_population . Crea una poblaci\u00f3n de individuos aleatorios. Para ello se utiliza una distribuci\u00f3n uniforme y se generan n\u00fameros aleatorios dentro de los l\u00edmites indicados para cada variable. Los individuos generados son almacenados en logger con la llave parent_population_x . Esta funci\u00f3n es llamada dentro de la funci\u00f3n optimize . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . Cada fila representa un individuo, cada columna indica los valores para cada variable de decisi\u00f3n del individuo. initialize_step_weights . Inicializa el tama\u00f1o de desplazamiento de cada individuo de la poblaci\u00f3n, por defecto se emplea un sigma por cada variable de decisi\u00f3n en cada uno de los individuos. Para ello se generan n\u00fameros aleatorios en el intervalo \\([0,1]\\) , utilizando una distribuci\u00f3n uniforme. Los tama\u00f1os de desplazamiento est\u00e1n almacenados en logger con la llave parent_population_sigma . Argumentos: eps_sigma. Valor m\u00ednimo que pueden tomar sigma (tama\u00f1os de paso). **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . Cada fila almacena la informaci\u00f3n de los tama\u00f1os de paso de cada individuo, cada columna pertenece al tama\u00f1o de paso de una de las variables de decisi\u00f3n. crossover_operator. Genera \\(\\lambda\\) hijos (individuos nuevos), aplicando una recombinaci\u00f3n sexual. Es decir, se seleccionan dos individuos aleatoriamente de parent_population_x que actuar\u00e1n como padres y generar\u00e1n un hijo. Este procedimiento se repite \\(\\lambda\\) veces. Los nuevos individuos se almacenan en logger con la llave offspring_population_x . Argumentos: parent_ind1. \u00cdndices de los individuos que son seleccionados para actuar como padre 1. parent_ind2. \u00cdndices de los individuos que son seleccionados para actuar como padre 2. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los valores de las variables de decisi\u00f3n de los nuevos individuos. Por defecto la metaheur\u00edstica utiliza el operador de cruza discreta que se encuentra en utils.operators.crossover con el nombre de discrete . mutation_operator. Muta las variables de decisi\u00f3n de los individuos creados con el operador de cruza. Estos individuos est\u00e1n almacenados en el diccionario logger con la llave offspring_population_x . La mutaci\u00f3n se realiza de la siguiente forma por defecto: \\[\\begin{equation} \\label{eq:mutarVariables} x'_i = x_i + \\sigma'_i \\cdot N_i(0, 1) \\end{equation}\\] donde \\(x'_i\\) es la variable mutada, \\(x_i\\) la variable a mutar, \\(\\sigma'_i\\) el tama\u00f1o de paso (previamente mutado) y \\(N_{i}(0,1)\\) devuelve un n\u00famero aleatorio por cada variable de decisi\u00f3n utilizando una distribuci\u00f3n normal con media \\(0\\) y desviaci\u00f3n est\u00e1ndar igual con \\(1\\) . Nota . Es importante tener en cuenta que la fila \\(j\\) de offspring_population_x debe corresponder con la fila \\(j\\) de offspring_population_sigma . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy que almacena los nuevos valores de las variables de decisi\u00f3n. adaptive_crossover. Genera los tama\u00f1os de paso de los nuevos individuos, aplicando una recombinaci\u00f3n sexual. Utiliza las mismas parejas de padres que se usaron con el operador crossover_operator . Los nuevos tama\u00f1os de paso son almacenados en logger con la llave offspring_population_sigma . Argumentos: parent_ind1. \u00cdndices de los individuos que son seleccionados para actuar como padre 1. parent_ind2. \u00cdndices de los individuos que son seleccionados para actuar como padre 2. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los valores de los nuevos tama\u00f1os de paso. Por defecto la metaheur\u00edstica utiliza el operador de cruza intermedia que se encuentra en utils.operators.crossover con el nombre de intermediate . adaptive_mutation. Muta los tama\u00f1os de paso que se encuentran almacenados en el diccionario logger con la llave offspring_population_sigma . Este m\u00e9todo se ejecuta antes del m\u00e9todo mutation_operator . La mutaci\u00f3n se realiza de la siguiente forma por defecto: \\[\\begin{equation*} \\label{eq:mutarNSigmas} \\sigma'_i = \\sigma_i \\cdot e ^ {\\tau' \\cdot N(0,1) + \\tau \\cdot N_i(0,1)} \\end{equation*}\\] Donde, \\(\\sigma_{i}\\) es el tama\u00f1o de paso actual. \\(\\sigma'_{i}\\) es tama\u00f1o de paso mutado. \\(\\tau\\) est\u00e1 definido como \\(\\frac{1}{\\sqrt{2n}}\\) , donde, \\(n\\) es el n\u00famero de variables del problema. \\(\\tau'\\) est\u00e1 definido como \\(\\frac{1}{\\sqrt{2\\sqrt{n}}}\\) , donde, \\(n\\) es el n\u00famero de variables del problema. \\(N(0,1)\\) devuelve un n\u00famero aleatorio usando una distribuci\u00f3n normal con media 0 y desviaci\u00f3n est\u00e1ndar igual a 1. Es importante notar que se genera un \u00fanico n\u00famero aleatorio para todas las \\(\\sigma_{i}\\) . \\(N_{i}(0,1)\\) devuelve un n\u00famero aleatorio por \\(\\sigma_i\\) utilizando una distribuci\u00f3n normal con media 0 y desviaci\u00f3n estandas igual a 1. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los tama\u00f1os de desplazamiento para cada una de las variables de decisi\u00f3n de los individuos. survivor_selection. Selecciona los individuos que formar\u00e1n parte de la siguiente generaci\u00f3n. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un diccionario con las siguientes llaves: parent_population_fitness. El valor de aptitud de cada individuo que pasar\u00e1 a la siguiente generaci\u00f3n. parent_population_sigma. El/los valor(es) de desplazamiento de los individuos seleccionados. parent_population_x. el vector \\(\\vec{x}\\) de cada uno de los individuos. Por defecto la metaheur\u00edstica utiliza el esquema de selecci\u00f3n \\((\\mu + \\lambda)\\) que se encuentra en utils.operators.selection con el nombre de merge_selector .","title":"Estrategias evolutivas"},{"location":"EE/#configuracion-de-estrategias-evolutivas","text":"Se debe importar como sigue: 1 from pyristic.utils.helpers import EvolutionStrategyConfig EvolutionStrategyConfig (Configuraci\u00f3n de la metaheur\u00edstica) Variables cross_op. Variable con el operador de cruza. mutation_op. Variable con el operador de mutaci\u00f3n. survivor_selector. Variable con el esquema de selecci\u00f3n que decide cu\u00e1les individuos pasan a la siguiente generaci\u00f3n. fixer. Variable con una funci\u00f3n que determina qu\u00e9 hacer con los individuos que no cumplen las restricciones del problema. adaptive_crossover_op. Variable con el operador de cruza que se aplica a los tama\u00f1os de paso \\(\\sigma\\) . adaptive_mutation_op. Variable con el operador de mutaci\u00f3n que se aplica a los tama\u00f1os de paso \\(\\sigma\\) . M\u00e9todos cross. Actualiza el operador de cruza de la variable cross_op . Argumentos: crossover_. Funci\u00f3n o clase que realiza la cruza de la poblaci\u00f3n almacenada con la llave parent_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. mutate. Actualiza el operador de mutaci\u00f3n de la variable mutation_op . Argumentos: mutate_. Funci\u00f3n o clase que realiza la mutaci\u00f3n de la poblaci\u00f3n almacenada con la llave offspring_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de mutaci\u00f3n. El objetivo es poder aplicar varios operadores en cascada. survivor_selection. Actualiza el esquema de selecci\u00f3n de la variable survivor_selector . Argumentos: survivor_function. Funci\u00f3n o clase que realiza la selecci\u00f3n de individuos que formar\u00e1n parte de la siguiente generaci\u00f3n. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del esquema de selecci\u00f3n de sobrevivientes. El objetivo es poder aplicar varios operadores en cascada. fixer_invalide_solutions. Actualiza la funci\u00f3n de la variable fixer . Argumentos: fixer_function. Funci\u00f3n o clase que ajustar\u00e1 los individuos de la poblaci\u00f3n que no cumplen con las restricciones del problema. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n de la funci\u00f3n auxiliar. El objetivo es poder aplicar varios operadores en cascada. adaptive_crossover. Actualiza el operador de cruza de los \\(\\sigma\\) de la variable adaptive_crossover_op . Argumentos: adaptive_crossover_function. Funci\u00f3n o clase que cruza los tama\u00f1os de paso de los individuos seleccionados para la cruza. Estos tama\u00f1os de paso est\u00e1n almacenados en el diccionario logger con la llave offspring_population_sigma . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza en los tama\u00f1os de paso. El objetivo es poder aplicar varios operadores en cascada. adaptive_mutation. Actualiza el operador de mutaci\u00f3n de los \\(\\sigma\\) de la variable adaptive_mutation_op . Argumentos: adaptive_mutation_function. Funci\u00f3n o clase que muta los tama\u00f1os de paso que se encuentran en logger con la llave offspring_population_sigma . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de mutaci\u00f3n en los tama\u00f1os de paso. El objetivo es poder aplicar varios operadores en cascada.","title":"Configuraci\u00f3n de Estrategias evolutivas"},{"location":"EE/#ejemplo","text":"Hay varias formas de emplear la metaheur\u00edstica, le sugerimos revisar los ejemplos. A continuaci\u00f3n presentamos un ejemplo de empleo para el problema de ackley_: 1 2 3 4 5 6 7 8 9 10 configuration_ackley = ( EvolutionStrategyConfig () . survivor_selection ( selection . replacement_selector ()) . adaptive_mutation ( mutation . single_sigma_adaptive_mutator ( ackley_ [ 'decision_variables' ]) ) ) solver_ackley_custom = EvolutionStrategy ( ** ackley_ , config = configuration_ackley ) solver_ackley_custom . optimize ( 250 , 100 , 200 ) print ( solver_ackley_custom )","title":"Ejemplo"},{"location":"PE/","text":"Programaci\u00f3n evolutiva La b\u00fasqueda se importar: 1 from pyristic.heuristic.EvolutiveProgramming_search import EvolutionaryProgramming EvolutionaryProgramming (clase de la metaheur\u00edstica) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda con las siguientes llaves: best_individual. Mejor individuo encontrado. best_f. El vlor obtenido de la funci\u00f3n objetivo evaluado en el individuo almacenado en individual. current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. parent_population_x. Arreglo bidimensional de numpy que representa cada fila a un individuo de la poblaci\u00f3n, mientras, las columnas representan el n\u00famero de variables de decisi\u00f3n. offspring_population_x. Arreglo bidimensional de numpy que representa cada fila a un individuo de la poblaci\u00f3n, mientras, las columnas representan el n\u00famero de variables de decisi\u00f3n. parent_population_sigma. Arreglo de numpy que representa el desplazamiento de por variable de decisi\u00f3n de cada uno de los individuos. offspring_population_sigma. Arreglo de numpy que representa el desplazamiento de por variable de decisi\u00f3n de cada uno de los individuos. parent_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de parent_population_x. offspring_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de offspring_population_x. f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. Bounds. Representa los l\u00edmites definidos para cada una de las variables del problema. Se aceptan las siguientes representaciones: Arreglo de numpy con solo dos componentes num\u00e9ricas, donde, la primera componente es el l\u00edmite inferior y la segunda componente es el l\u00edmite superior. Esto significa que todas las variables de decisi\u00f3n estar\u00e1n definidas para el mismo intervalo. Arreglo bidimensional de numpy con dos arreglos de numpy, donde, el primer arreglo de numpy representa el l\u00edmite inferior para cada variable de decisi\u00f3n, mientras, la segunda componente representa el l\u00edmite superior para cada variable de decisi\u00f3n. Decision_variables. El n\u00famero de variables de decisi\u00f3n del problema. M\u00e9todos __init__. Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. decision_variables. N\u00famero que indica las variables de decisi\u00f3n del problema. constraints. Lista con las restricciones del problema. bounds. L\u00edmites del espacio de b\u00fasqueda de cada una de las variables de decisi\u00f3n del problema. config. Estructura de datos ( EvolutionaryProgrammingConfig ) con los operadores que se emplear\u00e1n en la b\u00fasqueda. Valor de retorno: Ninguno. optimize. m\u00e9todo principal, realiza la ejecuci\u00f3n de la metaheur\u00edstica. Argumentos: generations. N\u00famero de generaciones (iteraciones de la metaheur\u00edstica). size_population. Tama\u00f1o de la poblaci\u00f3n (n\u00famero de individuos). verbose. Indica si se imprime en qu\u00e9 iteraci\u00f3n se encuentra nuestra b\u00fasqueda. Por defecto, est\u00e1 en True. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Ninguno. mutatio_operator. Muta las variables de decisi\u00f3n que se encuentran almacenadas en el diccionario logger con la llave parent_population_x . Argumentos: **kwargs Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy representado a los nuevos individuos (se almacenar\u00e1n en logger con la llave offspring_population_x ). adaptive_mutation. Muta los tama\u00f1os de paso que se encuentran almacenados en el diccionario logger con la llave parent_population_sigma . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los tama\u00f1os de desplazamiento para cada una de las variables de decisi\u00f3n de los individuos (se almacenar\u00e1n en logger con la llave offspring_population_sigma ). survivor_selection. Selecci\u00f3n de los individuos que pasar\u00e1n a la siguiente generaci\u00f3n. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un diccionario con las siguientes llaves: parent_population_f. El valor de la funci\u00f3n objetivo de cada individuo que pasar\u00e1 a la siguiente generaci\u00f3n. parent_population_sigma. El/los valor(es) de desplazamiento de los individuos seleccionados. parent_population_x. el vector \\(\\vec{x}\\) de cada uno de los individuos. Por defecto la metaheur\u00edstica utiliza el esquema de selecci\u00f3n \\((\\mu + \\lambda)\\) que se encuentra en utils.operators.selection con el nombre de merge_selector. initialize_population. Crea una poblaci\u00f3n de individuos aleatorios. Para ello se utiliza una distribuci\u00f3n uniforme y se generan n\u00fameros aleatorios dentro de los l\u00edmites indicados para cada variable. Los individuos generados son almacenados en logger con la llave parent_population_x . Esta funci\u00f3n es llamada dentro de la funci\u00f3n optimize. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . El n\u00famero de filas es igual al tama\u00f1o de la poblaci\u00f3n y el n\u00famero de columnas es igual al n\u00famero de variables que tiene el problema que se est\u00e1 resolviendo. initialize_step_weights. Inicializa el tama\u00f1o de desplazamiento de cada una de las variables de decisi\u00f3n pertenecientes a cada individuo de la poblaci\u00f3n. Para ello se generan n\u00fameros aleatorios en el intervalo \\([0,1]\\) , utilizando una distribuci\u00f3n uniforme. Los tama\u00f1os de desplazamiento est\u00e1n almacenados en logger con la llave parent_population_sigma . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy. El n\u00famero de filas es igual al tama\u00f1o de la poblaci\u00f3n y el n\u00famero de columnas es igual al n\u00famero de variables que tiene el problema que se est\u00e1 resolviendo. Cada variable tiene su propio tama\u00f1o de paso. fixer. Si la soluci\u00f3n no est\u00e1 dentro de los l\u00edmites definidos para cada variable (restricciones de caja), actualiza el valor de la variable con el valor del l\u00edmite que rebas\u00f3. De lo contrario, regresa la misma soluci\u00f3n. Argumentos: ind. \u00cdndice del individuo. Valor de retorno: Un arreglo de numpy que reemplazar\u00e1 la soluci\u00f3n infactible de la poblaci\u00f3n con la llave offspring_population_x . Configuraci\u00f3n de programaci\u00f3n evolutiva Se debe importar como sigue: 1 from pyristic.utils.helpers import EvolutionaryProgrammingConfig EvolutionaryProgrammingConfig (Configuraci\u00f3n de la metaheur\u00edstica) Variables mutation_op. Variable con el operador de mutaci\u00f3n. survivor_selector. Variable con el esquema de selecci\u00f3n de los individuos que pasan a la siguiente generaci\u00f3n. fixer. Variable con una funci\u00f3n auxiliar para los individuos que no cumplen las restricciones del problema. adaptive_mutation_op. Variable con el operador de mutaci\u00f3n de los tama\u00f1os de paso \\(\\sigma\\) . M\u00e9todos mutate. Actualiza el operador de mutaci\u00f3n de la variable mutation_op . Argumentos: mutate_. Funci\u00f3n o clase que realiza la mutaci\u00f3n de la poblaci\u00f3n almacenada con la llave offspring_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. survivor_selection. Actualiza el esquema de selecci\u00f3n de la variable survivor_selector . Argumentos: survivor_function. Funci\u00f3n o clase que realiza la selecci\u00f3n de individuos para la pr\u00f3xima generaci\u00f3n. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. fixer_invalide_solutions. Actualiza la funci\u00f3n auxiliar de la variable fixer . Argumentos: fixer_function. Funci\u00f3n o clase que ajustar\u00e1 los individuos de la poblaci\u00f3n que no cumplen con al menos una de las restricciones del problema. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. adaptive_mutation. Actualiza el operador de mutaci\u00f3n de los \\(\\sigma\\) de la variable adaptive_mutation_op . Argumentos: adaptive_mutation_function. Funci\u00f3n o clase que muta los tama\u00f1os de paso que se encuentran en logger con la llave parent_population_sigma . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. Ejemplo Hay varias formas de emplear la metaheur\u00edstica, le sugerimos revisar los ejemplos. A continuaci\u00f3n presentamos un ejemplo de empleo para el problema de ackley_: 1 2 3 4 5 6 7 configuration = ( EvolutionaryProgrammingConfig () . adaptive_mutation ( mutation . sigma_ep_adaptive_mutator ( ackley_ [ 'decision_variables' ], 2.0 ) ) ) Optimizer_by_configuration = EvolutionaryProgramming ( ** ackley_ , config = configuration ) Optimizer_by_configuration . optimize ( 500 , 100 )","title":"Programaci\u00f3n evolutiva"},{"location":"PE/#programacion-evolutiva","text":"La b\u00fasqueda se importar: 1 from pyristic.heuristic.EvolutiveProgramming_search import EvolutionaryProgramming EvolutionaryProgramming (clase de la metaheur\u00edstica) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda con las siguientes llaves: best_individual. Mejor individuo encontrado. best_f. El vlor obtenido de la funci\u00f3n objetivo evaluado en el individuo almacenado en individual. current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. parent_population_x. Arreglo bidimensional de numpy que representa cada fila a un individuo de la poblaci\u00f3n, mientras, las columnas representan el n\u00famero de variables de decisi\u00f3n. offspring_population_x. Arreglo bidimensional de numpy que representa cada fila a un individuo de la poblaci\u00f3n, mientras, las columnas representan el n\u00famero de variables de decisi\u00f3n. parent_population_sigma. Arreglo de numpy que representa el desplazamiento de por variable de decisi\u00f3n de cada uno de los individuos. offspring_population_sigma. Arreglo de numpy que representa el desplazamiento de por variable de decisi\u00f3n de cada uno de los individuos. parent_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de parent_population_x. offspring_population_f. Arreglo de numpy que contiene el valor de la funci\u00f3n objetivo para cada uno de los individuos de la poblaci\u00f3n de offspring_population_x. f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. Bounds. Representa los l\u00edmites definidos para cada una de las variables del problema. Se aceptan las siguientes representaciones: Arreglo de numpy con solo dos componentes num\u00e9ricas, donde, la primera componente es el l\u00edmite inferior y la segunda componente es el l\u00edmite superior. Esto significa que todas las variables de decisi\u00f3n estar\u00e1n definidas para el mismo intervalo. Arreglo bidimensional de numpy con dos arreglos de numpy, donde, el primer arreglo de numpy representa el l\u00edmite inferior para cada variable de decisi\u00f3n, mientras, la segunda componente representa el l\u00edmite superior para cada variable de decisi\u00f3n. Decision_variables. El n\u00famero de variables de decisi\u00f3n del problema. M\u00e9todos __init__. Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. decision_variables. N\u00famero que indica las variables de decisi\u00f3n del problema. constraints. Lista con las restricciones del problema. bounds. L\u00edmites del espacio de b\u00fasqueda de cada una de las variables de decisi\u00f3n del problema. config. Estructura de datos ( EvolutionaryProgrammingConfig ) con los operadores que se emplear\u00e1n en la b\u00fasqueda. Valor de retorno: Ninguno. optimize. m\u00e9todo principal, realiza la ejecuci\u00f3n de la metaheur\u00edstica. Argumentos: generations. N\u00famero de generaciones (iteraciones de la metaheur\u00edstica). size_population. Tama\u00f1o de la poblaci\u00f3n (n\u00famero de individuos). verbose. Indica si se imprime en qu\u00e9 iteraci\u00f3n se encuentra nuestra b\u00fasqueda. Por defecto, est\u00e1 en True. **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Ninguno. mutatio_operator. Muta las variables de decisi\u00f3n que se encuentran almacenadas en el diccionario logger con la llave parent_population_x . Argumentos: **kwargs Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy representado a los nuevos individuos (se almacenar\u00e1n en logger con la llave offspring_population_x ). adaptive_mutation. Muta los tama\u00f1os de paso que se encuentran almacenados en el diccionario logger con la llave parent_population_sigma . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy con los tama\u00f1os de desplazamiento para cada una de las variables de decisi\u00f3n de los individuos (se almacenar\u00e1n en logger con la llave offspring_population_sigma ). survivor_selection. Selecci\u00f3n de los individuos que pasar\u00e1n a la siguiente generaci\u00f3n. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un diccionario con las siguientes llaves: parent_population_f. El valor de la funci\u00f3n objetivo de cada individuo que pasar\u00e1 a la siguiente generaci\u00f3n. parent_population_sigma. El/los valor(es) de desplazamiento de los individuos seleccionados. parent_population_x. el vector \\(\\vec{x}\\) de cada uno de los individuos. Por defecto la metaheur\u00edstica utiliza el esquema de selecci\u00f3n \\((\\mu + \\lambda)\\) que se encuentra en utils.operators.selection con el nombre de merge_selector. initialize_population. Crea una poblaci\u00f3n de individuos aleatorios. Para ello se utiliza una distribuci\u00f3n uniforme y se generan n\u00fameros aleatorios dentro de los l\u00edmites indicados para cada variable. Los individuos generados son almacenados en logger con la llave parent_population_x . Esta funci\u00f3n es llamada dentro de la funci\u00f3n optimize. Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy . El n\u00famero de filas es igual al tama\u00f1o de la poblaci\u00f3n y el n\u00famero de columnas es igual al n\u00famero de variables que tiene el problema que se est\u00e1 resolviendo. initialize_step_weights. Inicializa el tama\u00f1o de desplazamiento de cada una de las variables de decisi\u00f3n pertenecientes a cada individuo de la poblaci\u00f3n. Para ello se generan n\u00fameros aleatorios en el intervalo \\([0,1]\\) , utilizando una distribuci\u00f3n uniforme. Los tama\u00f1os de desplazamiento est\u00e1n almacenados en logger con la llave parent_population_sigma . Argumentos: **kwargs. Diccionario con argumentos externos a la b\u00fasqueda. Estos argumentos pueden ser empleados cuando se sobreescribe alguno de los m\u00e9todos que tiene la clase. Valor de retorno: Un arreglo bidimensional de numpy. El n\u00famero de filas es igual al tama\u00f1o de la poblaci\u00f3n y el n\u00famero de columnas es igual al n\u00famero de variables que tiene el problema que se est\u00e1 resolviendo. Cada variable tiene su propio tama\u00f1o de paso. fixer. Si la soluci\u00f3n no est\u00e1 dentro de los l\u00edmites definidos para cada variable (restricciones de caja), actualiza el valor de la variable con el valor del l\u00edmite que rebas\u00f3. De lo contrario, regresa la misma soluci\u00f3n. Argumentos: ind. \u00cdndice del individuo. Valor de retorno: Un arreglo de numpy que reemplazar\u00e1 la soluci\u00f3n infactible de la poblaci\u00f3n con la llave offspring_population_x .","title":"Programaci\u00f3n evolutiva"},{"location":"PE/#configuracion-de-programacion-evolutiva","text":"Se debe importar como sigue: 1 from pyristic.utils.helpers import EvolutionaryProgrammingConfig EvolutionaryProgrammingConfig (Configuraci\u00f3n de la metaheur\u00edstica) Variables mutation_op. Variable con el operador de mutaci\u00f3n. survivor_selector. Variable con el esquema de selecci\u00f3n de los individuos que pasan a la siguiente generaci\u00f3n. fixer. Variable con una funci\u00f3n auxiliar para los individuos que no cumplen las restricciones del problema. adaptive_mutation_op. Variable con el operador de mutaci\u00f3n de los tama\u00f1os de paso \\(\\sigma\\) . M\u00e9todos mutate. Actualiza el operador de mutaci\u00f3n de la variable mutation_op . Argumentos: mutate_. Funci\u00f3n o clase que realiza la mutaci\u00f3n de la poblaci\u00f3n almacenada con la llave offspring_population_x . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. survivor_selection. Actualiza el esquema de selecci\u00f3n de la variable survivor_selector . Argumentos: survivor_function. Funci\u00f3n o clase que realiza la selecci\u00f3n de individuos para la pr\u00f3xima generaci\u00f3n. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. fixer_invalide_solutions. Actualiza la funci\u00f3n auxiliar de la variable fixer . Argumentos: fixer_function. Funci\u00f3n o clase que ajustar\u00e1 los individuos de la poblaci\u00f3n que no cumplen con al menos una de las restricciones del problema. Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada. adaptive_mutation. Actualiza el operador de mutaci\u00f3n de los \\(\\sigma\\) de la variable adaptive_mutation_op . Argumentos: adaptive_mutation_function. Funci\u00f3n o clase que muta los tama\u00f1os de paso que se encuentran en logger con la llave parent_population_sigma . Valor de retorno: Retorna la configuraci\u00f3n con la actualizaci\u00f3n del operador de cruza. El objetivo es poder aplicar varios operadores en cascada.","title":"Configuraci\u00f3n de programaci\u00f3n evolutiva"},{"location":"PE/#ejemplo","text":"Hay varias formas de emplear la metaheur\u00edstica, le sugerimos revisar los ejemplos. A continuaci\u00f3n presentamos un ejemplo de empleo para el problema de ackley_: 1 2 3 4 5 6 7 configuration = ( EvolutionaryProgrammingConfig () . adaptive_mutation ( mutation . sigma_ep_adaptive_mutator ( ackley_ [ 'decision_variables' ], 2.0 ) ) ) Optimizer_by_configuration = EvolutionaryProgramming ( ** ackley_ , config = configuration ) Optimizer_by_configuration . optimize ( 500 , 100 )","title":"Ejemplo"},{"location":"SA/","text":"Recocido simulado La b\u00fasqueda de recocido simulado la podemos importar: 1 from pyristic.heuristic.SimulatedAnnealing_search import SimulatedAnnealing SimulatedAnnealing (Clase recocido simulado) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda con las siguientes llaves: best_individual. Mejor individuo encontrado. best_f. El valor obtenido de la funci\u00f3n objetivo de individual . temperature. Temperatura inicial que se actualizar\u00e1 cada iteraci\u00f3n. f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. M\u00e9todos __init__. Inicializa la clase. Argumentos: function. Funci\u00f3n objetivo. constraints. Lista con las restricciones del problema. Valor de retorno: Ninguno. optimize. m\u00e9todo principal, realiza la ejecuci\u00f3n empleando la metaheur\u00edstica llamada SimulatedAnnealing . Argumentos: Init. Soluci\u00f3n inicial, se admite un arreglo de numpy o una funci\u00f3n que retorne un arreglo de numpy . IniTemperature. Valor de punto flotante que indica con que temperatura inicia la b\u00fasqueda. eps. Valor de punto flotante que indica con que temperatura termina la b\u00fasqueda. **kwargs. Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Ninguno update_temperature. Funci\u00f3n que decrementa la temperatura. Argumentos: **kwargs Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: La nueva temperatura. Funciones que se deben sobreescribir get_neighbor. Genera una soluci\u00f3n realizando una variaci\u00f3n aleatoria en la soluci\u00f3n actual. Argumentos: x. Arreglo de numpy representando a la soluci\u00f3n actual. **kwargs Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Arreglo de numpy representando la soluci\u00f3n generada. Ejemplo Para emplear la b\u00fasqueda se debe crear una clase nueva que herede todos los m\u00e9todos de SimulatedAnnealing , por ejemplo: 1 2 3 4 5 6 7 class simulatedAnnealingExample ( SimulatedAnnealing ): def __init__ ( self , f_ : function_type , constraints_ : list ): super () . __init__ ( f_ , constraints_ ) def get_neighbor ( self , x : np . ndarray ) -> np . ndarray : # C\u00f3digo para su b\u00fasqueda.","title":"Recocido Simulado"},{"location":"SA/#recocido-simulado","text":"La b\u00fasqueda de recocido simulado la podemos importar: 1 from pyristic.heuristic.SimulatedAnnealing_search import SimulatedAnnealing SimulatedAnnealing (Clase recocido simulado) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda con las siguientes llaves: best_individual. Mejor individuo encontrado. best_f. El valor obtenido de la funci\u00f3n objetivo de individual . temperature. Temperatura inicial que se actualizar\u00e1 cada iteraci\u00f3n. f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. M\u00e9todos __init__. Inicializa la clase. Argumentos: function. Funci\u00f3n objetivo. constraints. Lista con las restricciones del problema. Valor de retorno: Ninguno. optimize. m\u00e9todo principal, realiza la ejecuci\u00f3n empleando la metaheur\u00edstica llamada SimulatedAnnealing . Argumentos: Init. Soluci\u00f3n inicial, se admite un arreglo de numpy o una funci\u00f3n que retorne un arreglo de numpy . IniTemperature. Valor de punto flotante que indica con que temperatura inicia la b\u00fasqueda. eps. Valor de punto flotante que indica con que temperatura termina la b\u00fasqueda. **kwargs. Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Ninguno update_temperature. Funci\u00f3n que decrementa la temperatura. Argumentos: **kwargs Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: La nueva temperatura. Funciones que se deben sobreescribir get_neighbor. Genera una soluci\u00f3n realizando una variaci\u00f3n aleatoria en la soluci\u00f3n actual. Argumentos: x. Arreglo de numpy representando a la soluci\u00f3n actual. **kwargs Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Arreglo de numpy representando la soluci\u00f3n generada.","title":"Recocido simulado"},{"location":"SA/#ejemplo","text":"Para emplear la b\u00fasqueda se debe crear una clase nueva que herede todos los m\u00e9todos de SimulatedAnnealing , por ejemplo: 1 2 3 4 5 6 7 class simulatedAnnealingExample ( SimulatedAnnealing ): def __init__ ( self , f_ : function_type , constraints_ : list ): super () . __init__ ( f_ , constraints_ ) def get_neighbor ( self , x : np . ndarray ) -> np . ndarray : # C\u00f3digo para su b\u00fasqueda.","title":"Ejemplo"},{"location":"helpers/","text":"Funciones auxiliares y funciones de prueba. Funciones de prueba En esta secci\u00f3n se describe los problemas de optimizaci\u00f3n continua implementados, estos se encuentran en: 1 import pyristic.utils.test_function as pcTest La representaci\u00f3n de las funciones implementadas es en un diccionario con las siguientes llaves: function : La funci\u00f3n a optimizar. constraints : Restricciones del problema. bounds : L\u00edmites para cada una de las variables del problema. Si nuestro problema todas las variables est\u00e1n en el mismo rango podemos expresarlo en un solo arreglo con el l\u00edmite inferio y l\u00edmite superior, sino, deben ser dos arreglos, expresando los l\u00edmites inferiores y l\u00edmites superiores. decision_variables : El n\u00famero de variables del problema. Observaciones Las metaheur\u00edsticas descritas de la librer\u00eda son para resolver problemas de minimizaci\u00f3n, entonces, se debe convertir el problema, es decir, \\(max \\{ f(x) \\}= min \\{ -f(x)\\}\\) Las llaves se\u00f1aladas, son importantes al momento de ser llamadas por la metaheur\u00edstica. Se debe emplear las mismas llaves. Las funciones prueba que est\u00e1n actualmente son: beale_ ackley_ himmelblau_ bukin_ Para mayor informaci\u00f3n, puedes revisar las funciones prueba en wikipedia . Evaluando nuestra metaheur\u00edstica Pyristic cuenta con una funci\u00f3n auxiliar get_stats para evaluar la eficacia de nuestro algoritmo al encontrar soluciones buenas. La podemos importar de la siguiente manera: 1 from pyristic.utils.helpers import get_stats Los par\u00e1metros son: optimizer : Nuestro objeto creado para resolver el problema (metaheur\u00edstica). NIter : N\u00famero de ejecuciones de nuestro objeto. OptArgs : Una tupla con los par\u00e1metros de nuestro algoritmo (al momento de ejecutar el m\u00e9todo optimize ). ExternOptArgs : Diccionario con los argumentos incluidos al momento de sobreescribir alguno de los m\u00e9todos en la metaheur\u00edstica desarrollada. Ejemplo utilizando get_stats 1 2 3 4 5 6 7 8 9 from pyristic.heuristic.EvolutionStrategy_search import EvolutionStrategy from pyristic.utils.test_function import beale_ from pyristic.utils.helpers import get_stats from pprint import pprint Beale = EvolutionStrategy ( ** beale_ ) args = ( 200 , 80 , 160 , False ) statistics = get_stats ( Beale , 21 , args ) pprint ( statistics )","title":"Funciones auxiliares y prueba"},{"location":"helpers/#funciones-auxiliares-y-funciones-de-prueba","text":"","title":"Funciones auxiliares y funciones de prueba."},{"location":"helpers/#funciones-de-prueba","text":"En esta secci\u00f3n se describe los problemas de optimizaci\u00f3n continua implementados, estos se encuentran en: 1 import pyristic.utils.test_function as pcTest La representaci\u00f3n de las funciones implementadas es en un diccionario con las siguientes llaves: function : La funci\u00f3n a optimizar. constraints : Restricciones del problema. bounds : L\u00edmites para cada una de las variables del problema. Si nuestro problema todas las variables est\u00e1n en el mismo rango podemos expresarlo en un solo arreglo con el l\u00edmite inferio y l\u00edmite superior, sino, deben ser dos arreglos, expresando los l\u00edmites inferiores y l\u00edmites superiores. decision_variables : El n\u00famero de variables del problema. Observaciones Las metaheur\u00edsticas descritas de la librer\u00eda son para resolver problemas de minimizaci\u00f3n, entonces, se debe convertir el problema, es decir, \\(max \\{ f(x) \\}= min \\{ -f(x)\\}\\) Las llaves se\u00f1aladas, son importantes al momento de ser llamadas por la metaheur\u00edstica. Se debe emplear las mismas llaves. Las funciones prueba que est\u00e1n actualmente son: beale_ ackley_ himmelblau_ bukin_ Para mayor informaci\u00f3n, puedes revisar las funciones prueba en wikipedia .","title":"Funciones de prueba"},{"location":"helpers/#evaluando-nuestra-metaheuristica","text":"Pyristic cuenta con una funci\u00f3n auxiliar get_stats para evaluar la eficacia de nuestro algoritmo al encontrar soluciones buenas. La podemos importar de la siguiente manera: 1 from pyristic.utils.helpers import get_stats Los par\u00e1metros son: optimizer : Nuestro objeto creado para resolver el problema (metaheur\u00edstica). NIter : N\u00famero de ejecuciones de nuestro objeto. OptArgs : Una tupla con los par\u00e1metros de nuestro algoritmo (al momento de ejecutar el m\u00e9todo optimize ). ExternOptArgs : Diccionario con los argumentos incluidos al momento de sobreescribir alguno de los m\u00e9todos en la metaheur\u00edstica desarrollada.","title":"Evaluando nuestra metaheur\u00edstica"},{"location":"helpers/#ejemplo-utilizando-get_stats","text":"1 2 3 4 5 6 7 8 9 from pyristic.heuristic.EvolutionStrategy_search import EvolutionStrategy from pyristic.utils.test_function import beale_ from pyristic.utils.helpers import get_stats from pprint import pprint Beale = EvolutionStrategy ( ** beale_ ) args = ( 200 , 80 , 160 , False ) statistics = get_stats ( Beale , 21 , args ) pprint ( statistics )","title":"Ejemplo utilizando get_stats"},{"location":"operadores/","text":"Operadores de c\u00f3mputo evolutivo Operadores de cruza Operadores por metaheur\u00edstica Estrategias evolutivas Algoritmos gen\u00e9ticos Operadores de mutaci\u00f3n Selecci\u00f3n de padres Selecci\u00f3n de sobrevivientes","title":"operadores para algoritmos de c\u00f3mputo evolutivo"},{"location":"operadores/#operadores-de-computo-evolutivo","text":"","title":"Operadores de c\u00f3mputo evolutivo"},{"location":"operadores/#operadores-de-cruza","text":"Operadores por metaheur\u00edstica Estrategias evolutivas Algoritmos gen\u00e9ticos","title":"Operadores de cruza"},{"location":"operadores/#operadores-de-mutacion","text":"","title":"Operadores de mutaci\u00f3n"},{"location":"operadores/#seleccion-de-padres","text":"","title":"Selecci\u00f3n de padres"},{"location":"operadores/#seleccion-de-sobrevivientes","text":"","title":"Selecci\u00f3n de sobrevivientes"},{"location":"tabu/","text":"B\u00fasqueda Tab\u00fa La b\u00fasqueda tab\u00fa la podemos importar: 1 from pyristic.heuristic.Tabu_search import TabuSearch TabuSearch (clase b\u00fasqueda tab\u00fa) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda con las siguientes llaves: best_individual. Mejor individuo encontrado. best_f. El valor obtenido de la funci\u00f3n objetivo de individual . current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. TL. Estructura de datos auxiliar que mantendr\u00e1 memoria de las soluciones encontradas durante el tiempo especificado en optimize , por defecto utiliza TabuList . f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. M\u00e9todos __init__. Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. constraints. Lista con las restricciones del problema. TabuStruct. Estructura de datos que almacena informaci\u00f3n de variaciones que mejoran la soluci\u00f3n. Valor de retorno: Ninguno. optimize. m\u00e9todo principal, realiza la ejecuci\u00f3n empleando la metaheur\u00edstica llamada TabuSearch . Argumentos: Init. Soluci\u00f3n inicial, se admite un arreglo de numpy o una funci\u00f3n que retorne un arreglo de numpy . iterations. N\u00famero de iteraciones. memory_time. Tiempo que permanecer\u00e1 una soluci\u00f3n en nuestra estructura llamada TabuList . **kwargs. Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: - Ninguno Funciones que se deben sobreescribir get_neighbors. Funci\u00f3n que genera el vecindario de soluciones de la soluci\u00f3n \\(x\\) . Argumentos: x. Arreglo de numpy representando a la soluci\u00f3n actual. **kwargs Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Arreglo bidimensional de numpy representando a todas las soluciones generadas desde la soluci\u00f3n \\(x\\) . encode_change. Revisa nuestra soluci\u00f3n actual \\(x\\) y la soluci\u00f3n generada para indicar en d\u00f3nde sucedi\u00f3 la peque\u00f1a variaci\u00f3n. Argumentos: neighbor. Arreglo de numpy representando una variaci\u00f3n de nuestra soluci\u00f3n actual \\(x\\) . x. Arreglo de numpy representando nuestra soluci\u00f3n actual. **kwargs. Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Lista con dos elementos, donde, la primera componente ser\u00e1 la posici\u00f3n \\(i\\) donde sucedi\u00f3 la variaci\u00f3n y la segunda componente es el elemento en la componente \\(i\\) de neighbor . Lista Tab\u00fa TabuList (clase lista tab\u00fa) Variables _TB. Lista de listas que representar\u00e1n las posiciones que fueron modificadas con un contador de tiempo. timer. El tiempo que durar\u00e1 cada soluci\u00f3n en la lista. M\u00e9todos push. Introduce los cambios que proporcionaron una mejora en la b\u00fasqueda. Argumentos: x. Arreglo con la siguiente informaci\u00f3n: Primera componente: posici\u00f3n (indice) donde se encontr\u00f3 una mejora en la funci\u00f3n objetivo. Segunda componente: valor por el cual mejor\u00f3 nuestra soluci\u00f3n. Tercera componente: iteraci\u00f3n en la que se realiz\u00f3 la mejora. Valor de retorno: Ninguno. find. Revisa si la nueva soluci\u00f3n sea una de las modificaciones hechas en iteraciones previas almacenadas en _TB . Argumentos: x. Arreglo de numpy que representa el cambio realizado en la soluci\u00f3n actual de la b\u00fasqueda, es decir, recibe el arreglo que retorna la funci\u00f3n encode_change(neighbor,x) . Valor de retorno: Valor booleano que indica si la modificaci\u00f3n en dicha soluci\u00f3n ya se encontraba en nuestra lista tab\u00fa. reset. Borra toda la informaci\u00f3n almacenada en nuestro contenedor _TB y actualiza la variable timer . Argumentos: timer. N\u00famero que representa el tiempo que durar\u00e1n ahora las soluciones en nuestra lista tab\u00fa. Valor de retorno: Ninguno. update. Realiza la actualizaci\u00f3n en el contendor _TB modificando el tiempo de cada uno de los individuos almacenados y elimina aquellos individuos que ya expir\u00f3 su tiempo. Argumentos: Ninguno. Valor de retorno: Ninguno. pop_back. Elimina el \u00faltimo elemento del contenedor _TB . Argumentos: Ninguno. Valor de retorno: Ninguno. get_back. Regresa el \u00faltimo elemento del contenedor _TB . Argumentos: Ninguno. Valor de retorno: Elemento del contendor _TB . Ejemplo Para emplear la b\u00fasqueda tab\u00fa se debe crear una clase nueva que herede todos los m\u00e9todos de TabuSearch , por ejemplo: 1 2 3 4 5 6 7 8 9 10 class tabuExample ( TabuList ): def __init__ ( self , f_ : function_type , constraints_ : list , TabuStruct_ ): super () . __init__ ( f_ , constraints_ , TabuStruct ) def get_neighbors ( self , x : np . ndarray , ** kwargs ) -> list : # C\u00f3digo para su b\u00fasqueda. def encode_change ( self , neighbor : ( list , np . ndarray ), x : ( list , np . ndarray ), ** kwargs ) -> list : # C\u00f3digo para su b\u00fasqueda","title":"B\u00fasqueda Tab\u00fa"},{"location":"tabu/#busqueda-tabu","text":"La b\u00fasqueda tab\u00fa la podemos importar: 1 from pyristic.heuristic.Tabu_search import TabuSearch TabuSearch (clase b\u00fasqueda tab\u00fa) Variables logger. Diccionario con informaci\u00f3n relacionada a la b\u00fasqueda con las siguientes llaves: best_individual. Mejor individuo encontrado. best_f. El valor obtenido de la funci\u00f3n objetivo de individual . current_iter. Iteraci\u00f3n actual de la b\u00fasqueda. total_iter. N\u00famero total de iteraciones. TL. Estructura de datos auxiliar que mantendr\u00e1 memoria de las soluciones encontradas durante el tiempo especificado en optimize , por defecto utiliza TabuList . f. Funci\u00f3n objetivo. Constraints. Lista de restricciones del problema. Las restricciones deben ser funciones que retornan True o False, indicando si cumple dicha restricci\u00f3n. M\u00e9todos __init__. Constructor de la clase. Argumentos: function. Funci\u00f3n objetivo. constraints. Lista con las restricciones del problema. TabuStruct. Estructura de datos que almacena informaci\u00f3n de variaciones que mejoran la soluci\u00f3n. Valor de retorno: Ninguno. optimize. m\u00e9todo principal, realiza la ejecuci\u00f3n empleando la metaheur\u00edstica llamada TabuSearch . Argumentos: Init. Soluci\u00f3n inicial, se admite un arreglo de numpy o una funci\u00f3n que retorne un arreglo de numpy . iterations. N\u00famero de iteraciones. memory_time. Tiempo que permanecer\u00e1 una soluci\u00f3n en nuestra estructura llamada TabuList . **kwargs. Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: - Ninguno Funciones que se deben sobreescribir get_neighbors. Funci\u00f3n que genera el vecindario de soluciones de la soluci\u00f3n \\(x\\) . Argumentos: x. Arreglo de numpy representando a la soluci\u00f3n actual. **kwargs Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Arreglo bidimensional de numpy representando a todas las soluciones generadas desde la soluci\u00f3n \\(x\\) . encode_change. Revisa nuestra soluci\u00f3n actual \\(x\\) y la soluci\u00f3n generada para indicar en d\u00f3nde sucedi\u00f3 la peque\u00f1a variaci\u00f3n. Argumentos: neighbor. Arreglo de numpy representando una variaci\u00f3n de nuestra soluci\u00f3n actual \\(x\\) . x. Arreglo de numpy representando nuestra soluci\u00f3n actual. **kwargs. Par\u00e1metros externos a la b\u00fasqueda. Valor de retorno: Lista con dos elementos, donde, la primera componente ser\u00e1 la posici\u00f3n \\(i\\) donde sucedi\u00f3 la variaci\u00f3n y la segunda componente es el elemento en la componente \\(i\\) de neighbor .","title":"B\u00fasqueda Tab\u00fa"},{"location":"tabu/#lista-tabu","text":"TabuList (clase lista tab\u00fa) Variables _TB. Lista de listas que representar\u00e1n las posiciones que fueron modificadas con un contador de tiempo. timer. El tiempo que durar\u00e1 cada soluci\u00f3n en la lista. M\u00e9todos push. Introduce los cambios que proporcionaron una mejora en la b\u00fasqueda. Argumentos: x. Arreglo con la siguiente informaci\u00f3n: Primera componente: posici\u00f3n (indice) donde se encontr\u00f3 una mejora en la funci\u00f3n objetivo. Segunda componente: valor por el cual mejor\u00f3 nuestra soluci\u00f3n. Tercera componente: iteraci\u00f3n en la que se realiz\u00f3 la mejora. Valor de retorno: Ninguno. find. Revisa si la nueva soluci\u00f3n sea una de las modificaciones hechas en iteraciones previas almacenadas en _TB . Argumentos: x. Arreglo de numpy que representa el cambio realizado en la soluci\u00f3n actual de la b\u00fasqueda, es decir, recibe el arreglo que retorna la funci\u00f3n encode_change(neighbor,x) . Valor de retorno: Valor booleano que indica si la modificaci\u00f3n en dicha soluci\u00f3n ya se encontraba en nuestra lista tab\u00fa. reset. Borra toda la informaci\u00f3n almacenada en nuestro contenedor _TB y actualiza la variable timer . Argumentos: timer. N\u00famero que representa el tiempo que durar\u00e1n ahora las soluciones en nuestra lista tab\u00fa. Valor de retorno: Ninguno. update. Realiza la actualizaci\u00f3n en el contendor _TB modificando el tiempo de cada uno de los individuos almacenados y elimina aquellos individuos que ya expir\u00f3 su tiempo. Argumentos: Ninguno. Valor de retorno: Ninguno. pop_back. Elimina el \u00faltimo elemento del contenedor _TB . Argumentos: Ninguno. Valor de retorno: Ninguno. get_back. Regresa el \u00faltimo elemento del contenedor _TB . Argumentos: Ninguno. Valor de retorno: Elemento del contendor _TB .","title":"Lista Tab\u00fa"},{"location":"tabu/#ejemplo","text":"Para emplear la b\u00fasqueda tab\u00fa se debe crear una clase nueva que herede todos los m\u00e9todos de TabuSearch , por ejemplo: 1 2 3 4 5 6 7 8 9 10 class tabuExample ( TabuList ): def __init__ ( self , f_ : function_type , constraints_ : list , TabuStruct_ ): super () . __init__ ( f_ , constraints_ , TabuStruct ) def get_neighbors ( self , x : np . ndarray , ** kwargs ) -> list : # C\u00f3digo para su b\u00fasqueda. def encode_change ( self , neighbor : ( list , np . ndarray ), x : ( list , np . ndarray ), ** kwargs ) -> list : # C\u00f3digo para su b\u00fasqueda","title":"Ejemplo"}]}