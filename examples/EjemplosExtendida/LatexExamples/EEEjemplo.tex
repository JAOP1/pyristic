
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{EEEjemplo}
    
    
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{Estrategias Evolutivas}\label{estrategias-evolutivas}

La librería \textbf{Pyristic} incluye una clase llamada
\texttt{EvolutionStrategy}, inspirada en la metaheurística de
\emph{Estrategias evolutivas} (EE), para resolver problemas de
minimización. Para trabajar con esta clase se requiere hacer lo
siguiente:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Definir:

  \begin{itemize}
  \tightlist
  \item
    La función objetivo \(f\).
  \item
    La lista de restricciones.
  \item
    Lista de límites inferiores y superiores.
  \item
    Configuración de operadores de la metaheurística (opcional).
  \end{itemize}
\item
  Crear una clase que herede de \texttt{EvolutionStrategy}.
\item
  Sobreescribir las siguientes funciones de la clase
  \texttt{EvolutionStrategy}:

  \begin{itemize}
  \tightlist
  \item
    initialize\_step\_weights (opcional)
  \item
    initialize\_population (opcional)
  \item
    fixer (opcional)
  \item
    mutation\_operator (opcional)
  \item
    crossover\_operator (opcional)
  \item
    adaptive\_crossover (opcional)
  \item
    adaptive\_mutation (opcional)
  \item
    survivor\_selection (opcional)
  \end{itemize}
\end{enumerate}

A continuación se mostrará cómo resolver dos problemas de optimización
continua usando la clase \texttt{EvolutionStrategy}. El primer paso es
importar la librería y los módulos que se van a utilizar.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{import} \PY{n+nn}{sys}
        \PY{k+kn}{import} \PY{n+nn}{os}
        
        \PY{c+c1}{\PYZsh{}library\PYZus{}path is the path where the Optimpy library is located.}
        \PY{n}{library\PYZus{}path} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{/home/dell/Documentos/Git\PYZus{}proejcts/optimizacion\PYZhy{}con\PYZhy{}metaheuristicas/}\PY{l+s+s2}{\PYZdq{}}
        \PY{c+c1}{\PYZsh{}library\PYZus{}path = \PYZdq{}/Users/adrianamenchacamendez/Documentos/enes\PYZus{}morelia/papime/optimizacion\PYZhy{}con\PYZhy{}metaheuristicas/\PYZdq{}}
        \PY{n}{sys}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{abspath}\PY{p}{(}\PY{n}{library\PYZus{}path}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \subsubsection{Librerías externas}\label{libreruxedas-externas}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{k+kn}{from} \PY{n+nn}{pprint} \PY{k}{import} \PY{n}{pprint}
        \PY{k+kn}{import} \PY{n+nn}{math}
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np} 
        \PY{k+kn}{import} \PY{n+nn}{copy}
        \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k}{import} \PY{n}{Image}
        \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k}{import} \PY{n}{HTML} 
\end{Verbatim}

    \subsubsection{\texorpdfstring{Componentes de
\texttt{pyristic}}{Componentes de pyristic}}\label{componentes-de-pyristic}

La estructura que está organizada la librería es: * Las metaheurísticas
están ubicadas en \texttt{heuristic}. * Las funciones de prueba están
ubicadas en \texttt{utils.test\_function}. * Las clases auxiliares para
mantener la información de los operadores que serán empleados para
alguna de las metaheurísticas basadas en los paradigmas del cómputo
evolutivo están ubicadas en \texttt{utils.helpers}. * Las
metaheurísticas basadas en los paradigmas del cómputo evolutivo dependen
de un conjunto de operadores (selección, mutación y cruza). Estos
operadores están ubicados en \texttt{utils.operators}.

Para demostrar el uso de nuestra metaheurística basada en
\emph{algoritmos geneticos} tenemos que importar la clase llamada
\texttt{Genetic} que se encuentra en
\texttt{heuristic.GeneticAlgorithm\_search}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{k+kn}{from} \PY{n+nn}{optimpy}\PY{n+nn}{.}\PY{n+nn}{heuristic}\PY{n+nn}{.}\PY{n+nn}{EvolutionStrategy\PYZus{}search} \PY{k}{import} \PY{n}{EvolutionStrategy}
        \PY{k+kn}{from} \PY{n+nn}{optimpy}\PY{n+nn}{.}\PY{n+nn}{utils}\PY{n+nn}{.}\PY{n+nn}{operators} \PY{k}{import} \PY{n}{selection}\PY{p}{,} \PY{n}{mutation}\PY{p}{,} \PY{n}{crossover} 
        \PY{k+kn}{from} \PY{n+nn}{optimpy}\PY{n+nn}{.}\PY{n+nn}{utils}\PY{n+nn}{.}\PY{n+nn}{test\PYZus{}function} \PY{k}{import} \PY{n}{beale\PYZus{}}\PY{p}{,} \PY{n}{ackley\PYZus{}}
        \PY{k+kn}{from} \PY{n+nn}{optimpy}\PY{n+nn}{.}\PY{n+nn}{utils}\PY{n+nn}{.}\PY{n+nn}{helpers} \PY{k}{import} \PY{n}{EvolutionStrategyConfig}\PY{p}{,}\PY{n}{get\PYZus{}stats}
\end{Verbatim}

    \subsection{\texorpdfstring{Clase
\texttt{EvolutionStrategy}}{Clase EvolutionStrategy}}\label{clase-evolutionstrategy}

\paragraph{Variables}\label{variables}

\begin{itemize}
\item
  \emph{\textbf{logger.}} Diccionario con información relacionada a la
  búsqueda.
\item
  \texttt{best\_individual.} Individuo con el mejor valor encontrado en
  la función objetivo.
\item
  \texttt{best\_f.} Valor de la función objetivo.
\item
  \texttt{current\_iter.} Iteración actual de la búsqueda.
\item
  \texttt{total\_iter.} Número total de iteraciones.
\item
  \texttt{parent\_population\_size.} Tamaño de la población de padres.
\item
  \texttt{offspring\_population\_size.} Tamaño de la población de hijos.
\item
  \texttt{parent\_population\_x.} Arreglo bidimensional de \emph{numpy}.
  Cada fila representa un individuo de la población actual y cada
  columna corresponde a una variable de decisión.
\item
  \texttt{offspring\_population\_x.} Arreglo bidimensional de
  \emph{numpy}. Cada fila representa un individuo de la población de
  hijos y cada columna corresponde a una variable de decisión.
\item
  \texttt{parent\_population\_sigma.} Arreglo de \emph{numpy}, donde,
  cada elemento representa el desplazamiento de todas las variables de
  decisión de cada individuo o un arreglo bidimensional de \emph{numpy},
  donde, cada fila representa el desplazamiento de cada una de las
  variables de decisión de un individuo.
\item
  \texttt{offspring\_population\_sigma.}Arreglo de \emph{numpy}, donde,
  cada elemento representa el desplazamiento de todas las variables de
  decisión de un individuo o un arreglo bidimensional de \emph{numpy},
  donde, cada fila representa el desplazamiento de cada una de las
  variables de decisión de un individuo.
\item
  \texttt{parent\_population\_f.} Arreglo de \emph{numpy} que contiene
  el valor de la función objetivo para cada uno de los individuos de la
  población con la llave \texttt{parent\_population\_x} en
  \texttt{logger}.
\item
  \texttt{offspring\_population\_f.} Arreglo de \emph{numpy} que
  contiene el valor de la función objetivo para cada uno de los
  individuos de la población con la llave
  \texttt{offspring\_population\_x}.
\item
  \emph{\textbf{f.}} Función objetivo.
\item
  \emph{\textbf{Constraints.}} Lista de restricciones del problema. Las
  restricciones deben ser funciones que retornan True o False, indicando
  si cumple dicha restricción.
\item
  \emph{\textbf{Bounds.}} Representa los límites definidos para cada una
  de las variables del problema. Se aceptan las siguientes
  representaciones:
\item
  Arreglo de \emph{numpy} con solo dos componentes numéricas, donde, la
  primera componente es el límite inferior y la segunda componente es el
  límite superior. Esto significa que todas las variables de decisión
  estarán definidas para el mismo intervalo.
\item
  Arreglo bidimensional de \emph{numpy} con únicamente dos filas, donde,
  la primer fila es el límite inferior para cada variable de decisión,
  mientras, la segunda fila representa el límite superior para cada
  variable de decisión.
\item
  \emph{\textbf{Decision\_variables.}} El número de variables de
  decisión del problema.
\end{itemize}

\paragraph{Métodos}\label{muxe9todos}

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{\_\_init\_\_.}} Constructor de la clase.
\end{itemize}

Argumentos: * \texttt{function.} Función objetivo. *
\texttt{decision\_variables.} Número de variables de decisión del
problema. * \texttt{constraints.} Lista con las restricciones del
problema (se describe los tipos de datos admisibles en el apartado de
variables de la clase con el nombre \texttt{Constraints}). *
\texttt{bounds.} Límites de las variables de decisión (se describe los
tipos de datos admisibles en el apartado de variables de la clase con el
nombre \texttt{Bounds}).\\
* \texttt{config.} Estructura de datos
(\texttt{EvolutionStrategyConfig}) con los operadores que se emplearán
en la búsqueda.

Valor de retorno: * Ninguno.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{optimize.}} Método principal, realiza la ejecución de la
  metaheurística.
\end{itemize}

Argumentos: * \texttt{generations.} Número de generaciones (iteraciones
de la metaheurística). * \texttt{population\_size.} Tamaño de la
población (número de individuos). * \texttt{offspring\_size.} Tamaño de
la población creada a partir de los operadores de cruza y mutación. *
\texttt{eps\_sigma.} Valor mínimo que pueden tener los tamaños de paso.
Por defecto, está en 0.001. * \texttt{verbose.} Indica si se imprime en
qué iteración se encuentra nuestra búsqueda. Por defecto, está en True.
* \texttt{**kwargs.} Diccionario con argumentos externos a la búsqueda.
Estos argumentos pueden ser empleados cuando se sobreescribe alguno de
los métodos que tiene la clase.

Valor de retorno: * Ninguno.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{fixer}}. Si la solución no está dentro de los límites
  definidos para cada variable (restricciones de caja), actualiza el
  valor de la variable con el valor del límite que rebasó. De lo
  contrario, regresa la misma solución.
\end{itemize}

Argumentos: * \texttt{ind.} Índice del individuo.

Valor de retorno: * Un arreglo de \emph{numpy} que reemplazará la
solución infactible.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{initialize\_population}}. Crea una población de
  individuos aleatorios. Para ello se utiliza una distribución uniforme
  y se generan números aleatorios dentro de los límites indicados para
  cada variable. Los individuos generados son almacenados en
  \texttt{logger} con la llave \texttt{parent\_population\_x}. Esta
  función es llamada dentro de la función \texttt{optimize}.
\end{itemize}

Argumentos: * \texttt{**kwargs.} Diccionario con argumentos externos a
la búsqueda. Estos argumentos pueden ser empleados cuando se
sobreescribe alguno de los métodos que tiene la clase.

Valor de retorno: * Un arreglo bidimensional de \emph{numpy}. Cada fila
representa un individuo, cada columna indica los valores para cada
variable de decisión del individuo.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{initialize\_step\_weights}}. Inicializa el tamaño de
  desplazamiento de cada individuo de la población, por defecto se
  emplea un sigma por cada variable de decisión en cada uno de los
  individuos. Para ello se generan números aleatorios en el intervalo
  \([0,1]\), utilizando una distribución uniforme. Los tamaños de
  desplazamiento están almacenados en logger con la llave
  \texttt{parent\_population\_sigma}.
\end{itemize}

Argumentos: * \texttt{eps\_sigma.} Valor mínimo que pueden tomar sigma
(tamaños de paso). * \texttt{**kwargs.} Diccionario con argumentos
externos a la búsqueda. Estos argumentos pueden ser empleados cuando se
sobreescribe alguno de los métodos que tiene la clase.

Valor de retorno: * Un arreglo bidimensional de \emph{numpy}. Cada fila
almacena la información de los tamaños de paso de cada individuo, cada
columna pertenece al tamaño de paso de una de las variables de decisión.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{crossover\_operator.}} Genera \(\lambda\) hijos
  (individuos nuevos), aplicando una recombinación sexual. Es decir, se
  seleccionan dos individuos aleatoriamente de
  \texttt{parent\_population\_x} que actuarán como padres y generarán un
  hijo. Este procedimiento se repite \(\lambda\) veces. Los nuevos
  individuos se almacenan en \texttt{logger} con la llave
  \texttt{offspring\_population\_x}.
\end{itemize}

Argumentos: * \texttt{parent\_ind1.} Índices de los individuos que son
seleccionados para actuar como padre 1. * \texttt{parent\_ind2.} Índices
de los individuos que son seleccionados para actuar como padre 2. *
\texttt{**kwargs.} Diccionario con argumentos externos a la búsqueda.
Estos argumentos pueden ser empleados cuando se sobreescribe alguno de
los métodos que tiene la clase.

Valor de retorno: * Un arreglo bidimensional de \emph{numpy} con los
valores de las variables de decisión de los nuevos individuos.

\emph{Por defecto la metaheurística utiliza el operador de cruza
discreta que se encuentra en \texttt{utils.operators.crossover} con el
nombre de \texttt{discrete}.}

    \begin{itemize}
\item
  \emph{\textbf{mutation\_operator.}} Muta las variables de decisión de
  los individuos creados con el operador de cruza. Estos individuos
  están almacenados en el diccionario \texttt{logger} con la llave
  \texttt{offspring\_population\_x}. La mutación se realiza de la
  siguiente forma por defecto:

  \begin{equation}
    \label{eq:mutarVariables}
    x'_i = x_i + \sigma'_i \cdot N_i(0, 1)
  \end{equation}
\end{itemize}

donde \(x'_i\) es la variable mutada, \(x_i\) la variable a mutar,
\(\sigma'_i\) el tamaño de paso (previamente mutado) y \(N_{i}(0,1)\)
devuelve un número aleatorio por cada variable de decisión utilizando
una distribución normal con media \(0\) y desviación estándar igual con
\(1\).

\emph{Nota}. Es importante tener en cuenta que la fila \(j\) de
\texttt{offspring\_population\_x} debe corresponder con la fila \(j\) de
\texttt{offspring\_population\_sigma}.

Argumentos: * \texttt{**kwargs.} Diccionario con argumentos externos a
la búsqueda. Estos argumentos pueden ser empleados cuando se
sobreescribe alguno de los métodos que tiene la clase.

Valor de retorno: * Un arreglo bidimensional de numpy que almacena los
nuevos valores de las variables de decisión.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{adaptive\_crossover.}} Genera los tamaños de paso de los
  nuevos individuos, aplicando una recombinación sexual. Utiliza las
  mismas parejas de padres que se usaron con el operador
  \texttt{crossover\_operator}. Los nuevos tamaños de paso son
  almacenados en \texttt{logger} con la llave
  \texttt{offspring\_population\_sigma}.
\end{itemize}

Argumentos: * \texttt{parent\_ind1.} Índices de los individuos que son
seleccionados para actuar como padre 1. * \texttt{parent\_ind2.} Índices
de los individuos que son seleccionados para actuar como padre 2. *
\texttt{**kwargs.} Diccionario con argumentos externos a la búsqueda.
Estos argumentos pueden ser empleados cuando se sobreescribe alguno de
los métodos que tiene la clase.

Valor de retorno: * Un arreglo bidimensional de \emph{numpy} con los
valores de los nuevos tamaños de paso.

\emph{Por defecto la metaheurística utiliza el operador de cruza
intermedia que se encuentra en \texttt{utils.operators.crossover} con el
nombre de \texttt{intermediate}.}

    \begin{itemize}
\item
  \emph{\textbf{adaptive\_mutation.}} Muta los tamaños de paso que se
  encuentran almacenados en el diccionario \texttt{logger} con la llave
  \texttt{offspring\_population\_sigma}. Este método se ejecuta antes
  del método \texttt{mutation\_operator}. La mutación se realiza de la
  siguiente forma por defecto:

  \begin{equation*}
    \label{eq:mutarNSigmas}
    \sigma'_i = \sigma_i \cdot e ^ {\tau' \cdot N(0,1) + \tau \cdot N_i(0,1)}
  \end{equation*}
\end{itemize}

Donde, * \(\sigma_{i}\) es el tamaño de paso actual. * \(\sigma'_{i}\)
es tamaño de paso mutado. * \(\tau\) está definido como
\(\frac{1}{\sqrt{2n}}\), donde, \(n\) es el número de variables del
problema. * \(\tau'\) está definido como \(\frac{1}{\sqrt{2\sqrt{n}}}\),
donde, \(n\) es el número de variables del problema. * \(N(0,1)\)
devuelve un número aleatorio usando una distribución normal con media 0
y desviación estándar igual a 1. Es importante notar que se genera un
único número aleatorio para todas las \(\sigma_{i}\). * \(N_{i}(0,1)\)
devuelve un número aleatorio por \(\sigma_i\) utilizando una
distribución normal con media 0 y desviación estandas igual a 1.

Argumentos: * \texttt{**kwargs.} Diccionario con argumentos externos a
la búsqueda. Estos argumentos pueden ser empleados cuando se
sobreescribe alguno de los métodos que tiene la clase.

Valor de retorno: * Un arreglo bidimensional de \emph{numpy} con los
tamaños de desplazamiento para cada una de las variables de decisión de
los individuos.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{survivor\_selection.}} Selecciona los individuos que
  formarán parte de la siguiente generación.
\end{itemize}

Argumentos: * \texttt{**kwargs.} Diccionario con argumentos externos a
la búsqueda. Estos argumentos pueden ser empleados cuando se
sobreescribe alguno de los métodos que tiene la clase.

Valor de retorno: * Un diccionario con las siguientes llaves: *
\texttt{parent\_population\_fitness.} El valor de aptitud de cada
individuo que pasará a la siguiente generación. *
\texttt{parent\_population\_sigma.} El/los valor(es) de desplazamiento
de los individuos seleccionados. * \texttt{parent\_population\_x.} el
vector \(\vec{x}\) de cada uno de los individuos.

\emph{Por defecto la metaheurística utiliza el esquema de selección
\((\mu + \lambda)\) que se encuentra en
\texttt{utils.operators.selection} con el nombre de
\texttt{merge\_selector}.}

    \subsection{\texorpdfstring{Clase
\texttt{EvolutionStrategyConfig}}{Clase EvolutionStrategyConfig}}\label{clase-evolutionstrategyconfig}

\paragraph{Variables}\label{variables}

\begin{itemize}
\tightlist
\item
  \emph{\textbf{cross\_op.}} Variable con el operador de cruza.
\item
  \emph{\textbf{mutation\_op.}} Variable con el operador de mutación.
\item
  \emph{\textbf{survivor\_selector.}} Variable con el esquema de
  selección que decide cuáles individuos pasan a la siguiente
  generación.
\item
  \emph{\textbf{fixer.}} Variable con una función que determina qué
  hacer con los individuos que no cumplen las restricciones del
  problema.
\item
  \emph{\textbf{adaptive\_crossover\_op.}} Variable con el operador de
  cruza que se aplica a los tamaños de paso \(\sigma\).
\item
  \emph{\textbf{adaptive\_mutation\_op.}} Variable con el operador de
  mutación que se aplica a los tamaños de paso \(\sigma\).
\end{itemize}

\paragraph{Métodos}\label{muxe9todos}

\begin{itemize}
\tightlist
\item
  \emph{\textbf{cross.}} Actualiza el operador de cruza de la variable
  \texttt{cross\_op}. Argumentos:
\item
  \texttt{crossover\_.} Función o clase que realiza la cruza de la
  población almacenada con la llave \texttt{parent\_population\_x}.
\end{itemize}

Valor de retorno: * Retorna la configuración con la actualización del
operador de cruza. El objetivo es poder aplicar varios operadores en
cascada.

\begin{itemize}
\tightlist
\item
  \emph{\textbf{mutate.}} Actualiza el operador de mutación de la
  variable \texttt{mutation\_op}.
\end{itemize}

Argumentos: * \texttt{mutate\_.} Función o clase que realiza la mutación
de la población almacenada con la llave
\texttt{offspring\_population\_x}.

Valor de retorno: * Retorna la configuración con la actualización del
operador de mutación. El objetivo es poder aplicar varios operadores en
cascada.

\begin{itemize}
\tightlist
\item
  \emph{\textbf{survivor\_selection.}} Actualiza el esquema de selección
  de la variable \texttt{survivor\_selector}.
\end{itemize}

Argumentos: * \texttt{survivor\_function.} Función o clase que realiza
la selección de individuos que formarán parte de la siguiente
generación.

Valor de retorno: * Retorna la configuración con la actualización del
esquema de selección de sobrevivientes. El objetivo es poder aplicar
varios operadores en cascada.

\begin{itemize}
\tightlist
\item
  \emph{\textbf{fixer\_invalide\_solutions.}} Actualiza la función de la
  variable \texttt{fixer}.
\end{itemize}

Argumentos: * \texttt{fixer\_function.} Función o clase que ajustará los
individuos de la población que no cumplen con las restricciones del
problema.

Valor de retorno: * Retorna la configuración con la actualización de la
función auxiliar. El objetivo es poder aplicar varios operadores en
cascada.

\begin{itemize}
\tightlist
\item
  \emph{\textbf{adaptive\_crossover.}} Actualiza el operador de cruza de
  los \(\sigma\) de la variable \texttt{adaptive\_crossover\_op}.
\end{itemize}

Argumentos: * \texttt{adaptive\_crossover\_function.} Función o clase
que cruza los tamaños de paso de los individuos seleccionados para la
cruza. Estos tamaños de paso están almacenados en el diccionario
\texttt{logger} con la llave \texttt{offspring\_population\_sigma}.

Valor de retorno: * Retorna la configuración con la actualización del
operador de cruza en los tamaños de paso. El objetivo es poder aplicar
varios operadores en cascada.

\begin{itemize}
\tightlist
\item
  \emph{\textbf{adaptive\_mutation.}} Actualiza el operador de mutación
  de los \(\sigma\) de la variable \texttt{adaptive\_mutation\_op}.
\end{itemize}

Argumentos: * \texttt{adaptive\_mutation\_function.} Función o clase que
muta los tamaños de paso que se encuentran en \texttt{logger}con la
llave \texttt{offspring\_population\_sigma}.

Valor de retorno: * Retorna la configuración con la actualización del
operador de mutación en los tamaños de paso. El objetivo es poder
aplicar varios operadores en cascada.

    \subsection{Descripción de
operadores}\label{descripciuxf3n-de-operadores}

Los operadores de mutación, cruza y selección con los que cuenta la
librería \textbf{Pyristic} son clases. La finalidad es unificar el
formato de todos los operadores al ser llamados por los métodos de la
clase \texttt{EvolutionStrategy}.

    \subsubsection{Operadores de mutación}\label{operadores-de-mutaciuxf3n}

    \paragraph{Operadores de mutación en los tamaños de
paso}\label{operadores-de-mutaciuxf3n-en-los-tamauxf1os-de-paso}

Los operadores de mutación en los tamaños de paso es necesario definir
la propiedad \texttt{length} (método con el decorador \emph{@property})
porque este método será llamado al inicializar
\texttt{parent\_population\_sigma} por la clase
\texttt{EvolutionStrategy}. El objetivo es conocer si será un \(\sigma\)
por individuo o por cada variable de decisión de cada uno de los
individuos.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{single\_sigma\_adaptive\_mutator}}. Muta el valor del
  tamaño de paso \(\sigma\), utilizado para mutar todas las variables de
  decisión de un individuo. La mutación se realiza como sigue:

  \begin{equation}
   \sigma' = \sigma \cdot e^{\tau \cdot N(0,1)}
  \end{equation}

  Donde \(\tau\) es un parámetro que proporciona el usuario. Sea \(n\)
  el número de variables de decisión del problema, su valor por defecto
  es:

  \begin{equation}
     \tau = \frac{1}{\sqrt{n}}
    \end{equation}
\end{itemize}

Constructor: * \texttt{decision\_variables.} Número de variables de
decisión del problema.

Métodos: * \emph{\textbf{length.}} Función auxiliar de la clase
\texttt{EvolutionStrategy} que indica cuántos tamaños de paso se
utilizan para cada individuo. En este caso cada individuo utiliza un
único tamaño de paso.

Argumentos: * No recibe ningún argumento.

Valor de retorno: * Número de sigma's empleados para cada individuo de
la población (este operador retorna 1).

\begin{itemize}
\tightlist
\item
  \emph{\textbf{\_\_call\_\_.}} Este método nos permite hacer que
  nuestra clase se comporte como una función.
\end{itemize}

Argumentos: * \texttt{sigma.} Arreglo de \emph{numpy} con \(m\) valores
\(\sigma\). \(m\) es el tamaño de la población.

Valor de retorno: * Arreglo \emph{numpy} con los nuevos valores de
\(\sigma'\).

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{mult\_sigma\_adaptive\_mutator}}. Muta los valores de
  los tamaños de paso, considerando el uso de un tamaño de paso por
  variable de decisión. La mutación se realiza de la siguiente forma:

  \begin{equation}
  \sigma'_i = \sigma_i \cdot e ^ {\tau' \cdot N(0,1) + \tau \cdot N_i(0,1)}
  \end{equation}

  Donde \(\tau\) es un parámetro que proporciona el usuario. Sea \(n\)
  el número de variables de decisión, los valores por defecto son
  \(\tau' = \frac{1}{\sqrt{2n}}\) y \$\tau = \frac{1}{\sqrt{2 \sqrt{n}}}
  \$.
\end{itemize}

Constructor: * \texttt{decision\_variables.} Número de variables de
decisión del problema.

Métodos: * \emph{\textbf{length.}} Función auxiliar para la clase
\texttt{EvolutionStrategy} que indica cuántos tamaños de paso debe tener
cada individuo. En este caso es un tamaño de paso por cada variable de
decisión de cada individuo.

Argumentos: * No recibe ningún argumento.

Valor de retorno: * Número de sigma's empleados para cada individuo de
la población (este operador retorna el número de variables de decisión
del problema).

\begin{itemize}
\tightlist
\item
  \emph{\textbf{\_\_call\_\_.}} Este método nos permite hacer que
  nuestra clase se comporte como una función.
\end{itemize}

Argumentos: * \texttt{sigma.}Arreglo bidimensional de \emph{numpy}. Cada
fila contiene los valores \(\sigma_i\) de uno de los individuos de la
población.

Valor de retorno: * Arreglo \emph{numpy} con los valores mutados
\(\sigma'_i\).

    \subsubsection{Operadores de cruza}\label{operadores-de-cruza}

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{discrete}}. Operador de cruza discreta. Sean \(\vec{x}\)
  y \(\vec{y}\) los padres 1 y 2, respectivamente. El nuevo individuo
  \(\vec{z}\) está dado por:

  \begin{equation}
    z_{i} = 
    \begin{cases}
     x_{i} & \text{Si } b_{i} = 1, \\
     x_{i}  & \text{Si } b_{i} = 0 \\
    \end{cases}
  \end{equation}
\end{itemize}

Donde \(\vec{b}\) es un vector con valores aleatorios binarios del
tamaño de las variables de decisión del problema y \(\vec{z}\) es el
individuo generado por la cruza.

Constructor: * No recibe ningún argumento.

Métodos:

\begin{itemize}
\tightlist
\item
  \emph{\textbf{\_\_call\_\_.}} Este método nos permite hacer que
  nuestra clase se comporte como una función.
\end{itemize}

Argumentos: * \texttt{population.} Arreglo bidimensional de
\emph{numpy}. Cada fila es un individuo de la población actual. *
\texttt{parent\_ind1.} Arreglo de \emph{numpy} que contiene los índices
de los individuos seleccionados de \texttt{population} que actuarán como
padre 1. * \texttt{parent\_ind2.} Arreglo de \emph{numpy} que contiene
los índices de los individuos seleccionados de \texttt{population} que
actuarán como padre 2.

Valor de retorno: * Arreglo bidimensional de \emph{numpy}. Cada fila es
un individuo generado por la cruza.

    \begin{itemize}
\tightlist
\item
  \textbf{intermediate}. Operador de cruza intermedia. Sean \(\vec{x}\)
  y \(\vec{y}\) los padres 1 y 2, respectivamente, el nuevo individuo
  \(\vec{z}\) está dado por:

  \begin{equation}
  z_{i} = \alpha \cdot x_{i} + (1 - \alpha) \cdot y_{i}
  \end{equation}
\end{itemize}

Donde \(\alpha\) es un parámetro proporcionado por el usuario.

Constructor: * \texttt{Alpha.} Proporción en la que contribuye cada
padre para generar al nuevo individuo. Por defecto es 0.5.

Métodos: * \emph{\textbf{\_\_call\_\_.}} Este método nos permite hacer
que nuestra clase se comporte como una función.

Argumentos: * \texttt{population.} Arreglo bidimensional de numpy. Cada
fila es un individuo de la población actual. * \texttt{parent\_ind1.}
Arreglo de numpy que contiene los índices de los individuos
seleccionados de population que actuarán como padre 1. *
\texttt{parent\_ind2.} Arreglo de numpy que contiene los índices de los
individuos seleccionados de population que actuarán como padre 2.

Valor de retorno: * Arreglo bidimensional de \emph{numpy}. Cada fila es
un individuo generado por la cruza.

    \subsubsection{Operadores de selección de
sobrevivientes}\label{operadores-de-selecciuxf3n-de-sobrevivientes}

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{merge\_selector.}} Esquema \((\mu + \lambda)\),
  selecciona \(\mu\) individuos que son obtenidos al unir la población
  de hijos y la población actual. Los individuos que permanecerán en la
  próxima generación son aquellos que tengan un mejor valor de aptitud.
\end{itemize}

Constructor: * No recibe ningún parámetro.

Métodos: * \emph{\textbf{\_\_call\_\_.}} Este método nos permite hacer
que nuestra clase se comporte como una función.

Argumentos: * \texttt{parent\_f.} Arreglo de \emph{numpy} que contiene
la aptitud de cada individuo de la población actual. *
\texttt{offspring\_f.} Arreglo de \emph{numpy} que contiene la aptitud
de cada individuo de la población de hijos. * \texttt{features.}
Diccionario que almacena la información de las poblaciones. Cada llave
del diccionario almacenará una lista con dos componentes, donde, la
primera componente es la información de la población actual
\texttt{parent\_population} y la segunda componente es la información de
la población de hijos \texttt{offspring\_population}.

Valor de retorno: * Diccionario con los individuos seleccionados por
dicho esquema. Las llaves de este diccionario serán las mismas llaves
recibidas en el parámetro \texttt{features} y adicional otra llave con
el nombre \texttt{parent\_population\_f}, donde, ahora sólo contendrá la
información de los individuos que pasarán a la próxima generación.

    \begin{itemize}
\tightlist
\item
  \emph{\textbf{replacement\_selector.}} Esquema \((\mu, \lambda)\),
  reemplaza la población actual con los \(\mu\) mejores hijos de acuerdo
  a su valor de aptitud.
\end{itemize}

Constructor: * No recibe ningún parámetro.

Métodos: * \emph{\textbf{\_\_call\_\_.}} Este método nos permite hacer
que nuestra clase se comporte como una función.

Argumentos: * \texttt{parent\_fitness.} Arreglo de \emph{numpy} que
contiene la aptitud de cada individuo de la población actual. *
\texttt{offspring\_fitness.} Arreglo de \emph{numpy} que contiene la
aptitud de cada individuo de la población de hijos. * \texttt{features.}
Diccionario que almacena la información de las poblaciones. La primera
componente es la información de la población actual
\texttt{parent\_population} y la segunda componente es la información de
la población de hijos \texttt{offspring\_population}.

Valor de retorno: * Diccionario con los individuos seleccionados por
dicho esquema. Las llaves de este diccionario serán las mismas llaves
recibidas en el parámetro \texttt{features} y adicional otra llave con
el nombre \texttt{parent\_population\_f}, donde, ahora sólo contendrá la
información de los individuos que pasarán a la próxima generación.

    \subsection{Función de Beale}\label{funciuxf3n-de-beale}

\begin{equation}
  \label{eq:BF}
  \begin{array}{rll}
  \text{minimizar:} & f(x_1, x_2) = (1.5 - x_1 + x_1x_2)^2 + (2.25 - x_1 + x_1x_2^2)^2 + (2.625 - x_1 + x_1x_2^3)^2
  &  \\
  \text{Tal que: } & -4.5 \leq x_1,x_2 \leq 4.5 &  
  \end{array}
\end{equation}

El mínimo global se encuentra en \(x^* = (3, 0.5)\) y \(f(x^*) = 0\).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n}{Image}\PY{p}{(}\PY{n}{filename}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{include/beale.png}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{width}\PY{o}{=}\PY{l+m+mi}{500}\PY{p}{,} \PY{n}{height}\PY{o}{=}\PY{l+m+mi}{300}\PY{p}{)}
\end{Verbatim}
\texttt{\color{outcolor}Out[{\color{outcolor}4}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{EEEjemplo_files/EEEjemplo_30_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    La librería \textbf{Pyristic} tiene implementados algunos problemas de
prueba en \textbf{utils.helpers.test\_function}, entre ellos la función
de Beale. Los problemas de prueba están definidos como diccionarios con
las siguientes llaves:

\begin{itemize}
\tightlist
\item
  \texttt{function.} Función objetivo.
\item
  \texttt{constraints.} Lista con las funciones que validan las
  diferentes restricciones del problema. Todas las funciones deben
  regresar un valor booleano.
\item
  \texttt{bounds.} Límites para cada una de las variables del problema.
  En el caso de que todas las variables del problema compartan el mismo
  intervalo de búsqueda, se utiliza una lista con dos valores numéricos.
  El primero indica el límite inferior y el segundo el límite superior.
  En caso contrario, se tendrá una lista con dos listas internas. La
  primera lista almacena los límites inferiores y la segunda los límites
  superiores.
\item
  \texttt{decision\_variables.} Número de variables de decisión.
\end{itemize}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{beale\PYZus{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}5}]:} \{'function': CPUDispatcher(<function beale\_function at 0x7f4b5862a268>),
         'constraints': [CPUDispatcher(<function constraint1\_beale at 0x7f4b50b47400>)],
         'bounds': [-4.5, 4.5],
         'decision\_variables': 2\}
\end{Verbatim}
            
    \subsubsection{\texorpdfstring{Declaración de
\texttt{EvolutionStrategy}}{Declaración de EvolutionStrategy}}\label{declaraciuxf3n-de-evolutionstrategy}

La metaheurística de EE implementada en la librería de \textbf{Pyristic}
se puede utilizar de las siguientes maneras:

\begin{itemize}
\tightlist
\item
  Crear una clase que herede de la clase \texttt{EvolutionStrategy} y
  sobreescribir alguno de los métodos.
\item
  Declarar un objeto de tipo \emph{EvolutionStrategyConfig}, ubicado en
  \emph{utils.helpers}, y utilizarlo para inicializar un objeto de tipo
  \texttt{EvolutionStrategy}.
\item
  Realizar una combinación de las dos anteriores.
\end{itemize}

    Es importante resaltar que se puede hacer uso de la metaheurística sin
modificar los operadores que tiene por defecto.

    \subsection{Ejecución de la
metaheurística}\label{ejecuciuxf3n-de-la-metaheuruxedstica}

Como mencionamos antes, una forma de utilizar la metaheurística es hacer
una instancia de la clase \texttt{EvolutionStrategy} dejando su
configuración por defecto.

Los argumentos que se deben indicar al momento de inicializar son: *
función objetivo * restricciones del problema * límites inferior y
superior (por cada variable de decisión) * número de variables que tiene
el problema.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{Beale} \PY{o}{=} \PY{n}{EvolutionStrategy}\PY{p}{(}\PY{o}{*}\PY{o}{*}\PY{n}{beale\PYZus{}}\PY{p}{)}
\end{Verbatim}

    Recordemos que \texttt{beale\_} es un diccionario con la información
requerida por el constructor de la clase \texttt{EvolutionStrategy}.

    \subsubsection{\texorpdfstring{(\(\mu + \lambda\)) -
EE}{(\textbackslash{}mu + \textbackslash{}lambda) - EE}}\label{mu-lambda---ee}

Por defecto, la metaheurística trabaja de la siguiente forma: * Para la
selección de sobrevivientes utiliza un esquema \((\mu + \lambda)\). * El
operador de cruza para las variables de decisión es \emph{recombinación
discreta} (operador llamado \texttt{discrete}). * El operador de cruza
para los tamaños de paso es \emph{recombinación intermedia} (operador
llamado \texttt{intermediate}). * Cada individuo tiene un tamaño de paso
por variable. (operador llamado
\texttt{mult\_sigma\_adaptive\_mutator}).

    Una vez creado el objeto, se manda a llamar a su método
\texttt{optimize} el cual recibe los siguientes parámetros: *
\textbf{generations} = \(300\) * \textbf{population\_size} = \(80\) *
\textbf{offspring\_size} = \(160\)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n}{Beale}\PY{o}{.}\PY{n}{optimize}\PY{p}{(}\PY{l+m+mi}{300}\PY{p}{,}\PY{l+m+mi}{80}\PY{p}{,}\PY{l+m+mi}{160}\PY{p}{,}\PY{n}{verbose}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
100\%|██████████| 300/300 [00:02<00:00, 137.55it/s]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{Beale}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Evolution Strategy search: 
 f(X) = 3.611503831714945e-30 
 X = [3.  0.5] 
 Constraints: 
 x1: -4.5 <= 3.00 <= 4.5 
 x2: -4.5 <= 0.50 <= 4.5 


    \end{Verbatim}

    Para realizar un estudio estadístico del comportamiento de la
metaheurística, la librería \textbf{Pyristic} cuenta con una función
llamada \texttt{get\_stats}. Esta función se encuentra en
\texttt{utils.helpers} y recibe como parámetros:

\begin{itemize}
\tightlist
\item
  Objeto que realiza la ejecución de la metaheurística.
\item
  Número de veces que se quiere ejecutar la metaheurística.
\item
  Tupla con los argumentos que recibe la función \texttt{optimize}.
\item
  Argumentos adicionales a la búsqueda (opcional).
\end{itemize}

La función \textbf{get\_stats} considera la solución devuelta por la
metaheurística en cada ejecución y retorna un diccionario con la mejor y
peor solución encontrada y la media y desviación estándar del valor de
la función objetivo.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{200}\PY{p}{,} \PY{l+m+mi}{80}\PY{p}{,} \PY{l+m+mi}{160}\PY{p}{,} \PY{k+kc}{False}\PY{p}{)}
        \PY{n}{statistics} \PY{o}{=} \PY{n}{get\PYZus{}stats}\PY{p}{(}\PY{n}{Beale}\PY{p}{,} \PY{l+m+mi}{21}\PY{p}{,} \PY{n}{args}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
100\%|██████████| 200/200 [00:00<00:00, 879.28it/s]
100\%|██████████| 200/200 [00:00<00:00, 951.39it/s]
100\%|██████████| 200/200 [00:00<00:00, 960.63it/s]
100\%|██████████| 200/200 [00:00<00:00, 973.71it/s]
100\%|██████████| 200/200 [00:00<00:00, 976.13it/s]
100\%|██████████| 200/200 [00:00<00:00, 919.00it/s]
100\%|██████████| 200/200 [00:00<00:00, 937.10it/s]
100\%|██████████| 200/200 [00:00<00:00, 935.06it/s]
100\%|██████████| 200/200 [00:00<00:00, 853.74it/s]
100\%|██████████| 200/200 [00:00<00:00, 939.06it/s]
100\%|██████████| 200/200 [00:00<00:00, 954.97it/s]
100\%|██████████| 200/200 [00:00<00:00, 982.70it/s]
100\%|██████████| 200/200 [00:00<00:00, 932.86it/s]
100\%|██████████| 200/200 [00:00<00:00, 949.30it/s]
100\%|██████████| 200/200 [00:00<00:00, 936.19it/s]
100\%|██████████| 200/200 [00:00<00:00, 965.96it/s]
100\%|██████████| 200/200 [00:00<00:00, 956.43it/s]
100\%|██████████| 200/200 [00:00<00:00, 768.09it/s]
100\%|██████████| 200/200 [00:00<00:00, 887.89it/s]
100\%|██████████| 200/200 [00:00<00:00, 930.53it/s]
100\%|██████████| 200/200 [00:00<00:00, 977.60it/s]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n}{pprint}\PY{p}{(}\PY{n}{statistics}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\{'Best solution': \{'f': 7.65172802912719e-24, 'x': array([3. , 0.5])\},
 'Mean': 4.2654367173737946e-13,
 'Median': 1.1990144937278418e-19,
 'Standard deviation': 1.9074148651240894e-12,
 'Worst solution': \{'f': 8.956762249866645e-12,
                    'x': array([3.00000465, 0.50000164])\}\}

    \end{Verbatim}

    \subsubsection{(1+1) - EE}\label{ee}

A continuación vamos a implementar la EE más simple conocida como
\((1+1)-\)EE para resolver la función de Beale. \((1+1)-\)EE trabaja de
la siguiente forma:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Utiliza un único valor de \(\sigma\) para mutar todas las variables de
  decisión.
\item
  El valor de \(\sigma\) se autoadapta utilizando la regla del éxito del
  1/5.

  \begin{equation}
    \sigma =
    \begin{cases}
     \sigma / c & \text{Si } p_s > 1/5, \\
     \sigma \cdot c & \text{Si } p_s < 1/5, \\
     \sigma  & \text{Si } p_s = 1/5 \\
    \end{cases}
  \end{equation}
\item
  Se utiliza un solo individuo, éste es mutado para generar un hijo.

  \begin{equation}
    \label{eq:mutarVariables}
     x'_i = x_i + \sigma'_i \cdot N_i(0, 1)
  \end{equation}
\item
  El individuo más apto es el que pasará a la siguiente generación.
\end{enumerate}

Esta versión no considera un operador de cruza. Por este motivo, vamos a
sobreescribir \texttt{crossover\_operator} y
\texttt{adaptive\_crossover} para que retornen el individuo original sin
cambio alguno. Las funciones que debemos sobreescribir son: *
crossover\_operator * adaptive\_crossover * adaptive\_mutation *
mutation\_operator * initializing\_step\_weights

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{k}{class} \PY{n+nc}{ESBasic}\PY{p}{(}\PY{n}{EvolutionStrategy}\PY{p}{)}\PY{p}{:}
             \PY{k}{def} \PY{n+nf}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{function}  \PY{p}{,}\PYZbs{}
                          \PY{n}{decision\PYZus{}variables}\PY{p}{:}\PY{n+nb}{int}\PY{p}{,}\PYZbs{}
                          \PY{n}{constraints}\PY{p}{:} \PY{n+nb}{list}\PY{p}{,}\PYZbs{}
                          \PY{n}{bounds}\PY{p}{:} \PY{n}{np}\PY{o}{.}\PY{n}{ndarray}\PY{p}{)}\PY{p}{:}
                 \PY{n+nb}{super}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n}{function}\PY{p}{,} \PY{n}{decision\PYZus{}variables}\PY{p}{,} \PY{n}{constraints}\PY{p}{,} \PY{n}{bounds}\PY{p}{)}
                 
                 \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{successful} \PY{o}{=} \PY{l+m+mi}{0}
         
             
             \PY{k}{def} \PY{n+nf}{crossover\PYZus{}operator}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{parent\PYZus{}ind1}\PY{p}{,}\PYZbs{}
                                          \PY{n}{parent\PYZus{}ind2}\PY{p}{,}\PYZbs{}
                                          \PY{o}{*}\PY{o}{*}\PY{n}{kargs}\PY{p}{)}\PY{p}{:}
                 \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{parent\PYZus{}population\PYZus{}x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             
             \PY{k}{def} \PY{n+nf}{adaptive\PYZus{}crossover}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{parent\PYZus{}ind1}\PY{p}{,}\PYZbs{}
                                          \PY{n}{parent\PYZus{}ind2}\PY{p}{,}\PYZbs{}
                                          \PY{o}{*}\PY{o}{*}\PY{n}{kargs}\PY{p}{)}\PY{p}{:}
                 \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{parent\PYZus{}population\PYZus{}sigma}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
             
             \PY{k}{def} \PY{n+nf}{adaptive\PYZus{}mutation}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{o}{*}\PY{o}{*}\PY{n}{kargs}\PY{p}{)}\PY{p}{:}
                 
                     \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{current\PYZus{}iter}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{\PYZpc{}} \PY{n}{kargs}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{:}
                         \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offspring\PYZus{}population\PYZus{}sigma}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
                     
                     \PY{n}{ps} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{successful} \PY{o}{/} \PY{n}{kargs}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
                     \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{successful} \PY{o}{=} \PY{l+m+mi}{0}
                     \PY{k}{if}\PY{p}{(} \PY{n}{ps} \PY{o}{\PYZgt{}} \PY{l+m+mi}{1}\PY{o}{/}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offspring\PYZus{}population\PYZus{}sigma}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{o}{/}\PY{n}{kargs}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
                     \PY{k}{elif}\PY{p}{(} \PY{n}{ps} \PY{o}{\PYZlt{}} \PY{l+m+mi}{1}\PY{o}{/}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offspring\PYZus{}population\PYZus{}sigma}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{o}{*}\PY{n}{kargs}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
                     \PY{k}{else}\PY{p}{:}
                         \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offspring\PYZus{}population\PYZus{}sigma}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
                     
             \PY{k}{def} \PY{n+nf}{mutation\PYZus{}operator}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{o}{*}\PY{o}{*}\PY{n}{kargs}\PY{p}{)}\PY{p}{:}
                 \PY{n}{X\PYZus{}mutated} \PY{o}{=} \PY{n}{copy}\PY{o}{.}\PY{n}{deepcopy}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offspring\PYZus{}population\PYZus{}x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
                 \PY{n}{X\PYZus{}mutated} \PY{o}{+}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offspring\PYZus{}population\PYZus{}sigma}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{normal}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{n}{X\PYZus{}mutated}\PY{o}{.}\PY{n}{shape}\PY{p}{)} 
         
                 \PY{k}{if}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{f}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{offspring\PYZus{}population\PYZus{}x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{f}\PY{p}{(}\PY{n}{X\PYZus{}mutated}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{:}
                     \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{successful}\PY{o}{+}\PY{o}{=}\PY{l+m+mi}{1}
                 
                 \PY{k}{return} \PY{n}{X\PYZus{}mutated}
             
             \PY{k}{def} \PY{n+nf}{initializing\PYZus{}step\PYZus{}weights}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{eps\PYZus{}sigma}\PY{p}{:}\PY{n+nb}{int}\PY{p}{,} \PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n}{np}\PY{o}{.}\PY{n}{ndarray}\PY{p}{:}
                 \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{uniform}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{logger}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{parent\PYZus{}population\PYZus{}size}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n}{Beale\PYZus{}basic} \PY{o}{=} \PY{n}{ESBasic}\PY{p}{(}\PY{o}{*}\PY{o}{*}\PY{n}{beale\PYZus{}}\PY{p}{)}
\end{Verbatim}

    Como se puede observar, estamos haciendo uso del argumento llamado
\texttt{kargs}, el cual es un diccionario que contiene información
adicional. En este caso \texttt{kargs} contiene dos constantes: la
primera es el parámetro \(k\) que indica cada cuantas generaciones se va
a actualizar el valor de \(\sigma\) y la segunda es el valor del
parámetro \(c\) que se utiliza para actualizar el valor de \(\sigma\).
El diccionario tiene que ser incluido siempre con \texttt{**} antes del
nombre de la variable que lo almacena.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n}{additional\PYZus{}arguments} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{l+m+mi}{20}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{l+m+mf}{0.83}\PY{p}{\PYZcb{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{Beale\PYZus{}basic}\PY{o}{.}\PY{n}{optimize}\PY{p}{(}\PY{n}{generations}\PY{o}{=}\PY{l+m+mi}{200}\PY{p}{,}\PYZbs{}
                              \PY{n}{population\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,}\PYZbs{}
                              \PY{n}{offspring\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,}\PYZbs{}
                              \PY{o}{*}\PY{o}{*}\PY{n}{additional\PYZus{}arguments}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
100\%|██████████| 200/200 [00:00<00:00, 4906.57it/s]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{Beale\PYZus{}basic}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Evolution Strategy search: 
 f(X) = 2.4808725619230687 
 X = [-0.36423684  2.1653851 ] 
 Constraints: 
 x1: -4.5 <= -0.36 <= 4.5 
 x2: -4.5 <= 2.17 <= 4.5 


    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{500}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mf}{0.001}\PY{p}{,}\PY{k+kc}{False}\PY{p}{)}
         \PY{n}{statistics} \PY{o}{=} \PY{n}{get\PYZus{}stats}\PY{p}{(}\PY{n}{Beale\PYZus{}basic}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{,} \PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{additional\PYZus{}arguments} \PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n}{pprint}\PY{p}{(}\PY{n}{statistics}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\{'Best solution': \{'f': 5.095899477128232e-05,
                   'x': array([2.99200251, 0.49667427])\},
 'Mean': 1.2601353824910624,
 'Median': 0.00736331186772052,
 'Standard deviation': 2.8115480703491436,
 'Worst solution': \{'f': 9.718812230380905,
                    'x': array([ 0.04801314, -3.5862719 ])\}\}

    \end{Verbatim}

    \subsection{Función de Ackley}\label{funciuxf3n-de-ackley}

\begin{equation}
  \min f(\vec{x}) = -20\exp \left( -0.2 \sqrt{\frac{1}{n} \sum_{i=1}^n x_i^2} \right) 
  - exp \left( \frac{1}{n} \sum_{i=1}^n \cos (2\pi x_i) \right)
  + 20 + e  
\end{equation}

El mínimo global está en \$x\^{}* = 0 \$, \(f(\vec{x}) = 0\) y su
dominio es \(|x_{i}| < 30\).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{n}{Image}\PY{p}{(}\PY{n}{filename}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{include/ackley.jpg}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{width}\PY{o}{=}\PY{l+m+mi}{500}\PY{p}{,} \PY{n}{height}\PY{o}{=}\PY{l+m+mi}{300}\PY{p}{)}
\end{Verbatim}
\texttt{\color{outcolor}Out[{\color{outcolor}18}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{EEEjemplo_files/EEEjemplo_55_0.jpeg}
    \end{center}
    { \hspace*{\fill} \\}
    

    Al igual que la función de Beale, la librería \textbf{Pyristic} tiene
implementada la función de Ackley en
\texttt{utils.helpers.test\_function}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{n}{ackley\PYZus{}}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}19}]:} \{'function': CPUDispatcher(<function ackley\_function at 0x7f4b3c06e2f0>),
          'constraints': [CPUDispatcher(<function constraint1\_ackley at 0x7f4b3c06e598>)],
          'bounds': [-30.0, 30.0],
          'decision\_variables': 10\}
\end{Verbatim}
            
    Este problema no se encuentra restringido a un número de variables de
decisión. Para modificar el número de variables de decisión hacemos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ackley_[}\StringTok{'decision_variables'}\NormalTok{] }\OperatorTok{=} \DecValTok{5}
\end{Highlighting}
\end{Shaded}

    \subsubsection{\texorpdfstring{(\(\mu+\lambda\))-EE}{(\textbackslash{}mu+\textbackslash{}lambda)-EE}}\label{mulambda-ee}

    Emplearemos la metaheurística de EE, con la configuración por defecto,
para resolver la función de Ackley con 10 variables de decisión.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{n}{Ackley} \PY{o}{=} \PY{n}{EvolutionStrategy}\PY{p}{(}\PY{o}{*}\PY{o}{*}\PY{n}{ackley\PYZus{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{l+s+sd}{\PYZsq{}\PYZsq{}\PYZsq{}}
         \PY{l+s+sd}{Número de generaciones: 250}
         \PY{l+s+sd}{Tamaño de población de padres: 100}
         \PY{l+s+sd}{Tamaño de población de hijos: 200}
         \PY{l+s+sd}{\PYZsq{}\PYZsq{}\PYZsq{}}
         \PY{n}{Ackley}\PY{o}{.}\PY{n}{optimize}\PY{p}{(}\PY{l+m+mi}{250}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{,}\PY{l+m+mi}{200}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
100\%|██████████| 250/250 [00:01<00:00, 149.82it/s]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{Ackley}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Evolution Strategy search: 
 f(X) = 0.19851402189488043 
 X = [ 0.06903314 -0.02719133 -0.01734121  0.0083857  -0.02041749  0.02305745
  0.04877207 -0.03463208 -0.03300106  0.01635406] 
 Constraints: 
 x1: -30 <= 0.07 <= 30 
 x2: -30 <= -0.03 <= 30 
 x3: -30 <= -0.02 <= 30 
 x4: -30 <= 0.01 <= 30 
 x5: -30 <= -0.02 <= 30 
 x6: -30 <= 0.02 <= 30 
 x7: -30 <= 0.05 <= 30 
 x8: -30 <= -0.03 <= 30 
 x9: -30 <= -0.03 <= 30 
 x10: -30 <= 0.02 <= 30 
  


    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{250}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{200}\PY{p}{,} \PY{l+m+mf}{0.001} \PY{p}{,}\PY{k+kc}{False}\PY{p}{)}
         \PY{n}{statistics} \PY{o}{=} \PY{n}{get\PYZus{}stats}\PY{p}{(}\PY{n}{Ackley}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{,} \PY{n}{args}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{n}{pprint}\PY{p}{(}\PY{n}{statistics}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\{'Best solution': \{'f': 0.008958576078040625,
                   'x': array([ 0.00155744, -0.00045284,  0.00207098, -0.00060489,  0.00262941,
        0.0008557 , -0.00080341,  0.00099172, -0.00170624,  0.00528233])\},
 'Mean': 0.08126613753517124,
 'Median': 0.04674853757252473,
 'Standard deviation': 0.07947966129764066,
 'Worst solution': \{'f': 0.3279831631361394,
                    'x': array([-0.03177579,  0.01487862, -0.03282081,  0.02822527, -0.07654211,
       -0.03552047, -0.01205284,  0.02290453,  0.11966758, -0.00441367])\}\}

    \end{Verbatim}

    \subsubsection{\texorpdfstring{(\(\mu,\lambda\))-EE}{(\textbackslash{}mu,\textbackslash{}lambda)-EE}}\label{mulambda-ee}

    Ahora vamos a utilizar una configuración del tipo
\texttt{EvolutionStrategyConfig} para definir los métodos que serán
empleados en nuestro objeto del tipo \texttt{EvolutionStrategy}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n}{configuration\PYZus{}ackley} \PY{o}{=} \PY{p}{(}\PY{n}{EvolutionStrategyConfig}\PY{p}{(}\PY{p}{)}
                                \PY{o}{.}\PY{n}{survivor\PYZus{}selection}\PY{p}{(}\PY{n}{selection}\PY{o}{.}\PY{n}{replacement\PYZus{}selector}\PY{p}{(}\PY{p}{)}\PY{p}{)}
                                \PY{o}{.}\PY{n}{adaptive\PYZus{}mutation}\PY{p}{(}
                                    \PY{n}{mutation}\PY{o}{.}\PY{n}{single\PYZus{}sigma\PYZus{}adaptive\PYZus{}mutator}\PY{p}{(}
                                                    \PY{n}{ackley\PYZus{}}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{decision\PYZus{}variables}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
                                                  \PY{p}{)}
                                \PY{p}{)}
\end{Verbatim}

    En este caso estamos modificando el esquema de selección de
sobrevivientes y emplearemos un único tamaño de paso para cada
individuo, donde, el argumento que tiene
\texttt{single\_sigma\_adaptive\_mutator} es el número de variables de
decisión del problema.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{configuration\PYZus{}ackley}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
--------------------------------
	Configuration
--------------------------------
Survivor selection: Replacement population
Adaptive mutation: Single Sigma

--------------------------------

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{n}{solver\PYZus{}ackley\PYZus{}custom} \PY{o}{=} \PY{n}{EvolutionStrategy}\PY{p}{(}\PY{o}{*}\PY{o}{*}\PY{n}{ackley\PYZus{}}\PY{p}{,}\PY{n}{config}\PY{o}{=}\PY{n}{configuration\PYZus{}ackley}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{solver\PYZus{}ackley\PYZus{}custom}\PY{o}{.}\PY{n}{optimize}\PY{p}{(}\PY{l+m+mi}{250}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{,}\PY{l+m+mi}{200}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
100\%|██████████| 250/250 [00:01<00:00, 164.92it/s]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{solver\PYZus{}ackley\PYZus{}custom}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Evolution Strategy search: 
 f(X) = 6.722875353277301 
 X = [-2.40256206  2.64503024  0.88760834 -2.27760043  1.01264436 -0.20435495
 -0.2826214  -0.1739199  -1.97614466  0.00283308] 
 Constraints: 
 x1: -30 <= -2.40 <= 30 
 x2: -30 <= 2.65 <= 30 
 x3: -30 <= 0.89 <= 30 
 x4: -30 <= -2.28 <= 30 
 x5: -30 <= 1.01 <= 30 
 x6: -30 <= -0.20 <= 30 
 x7: -30 <= -0.28 <= 30 
 x8: -30 <= -0.17 <= 30 
 x9: -30 <= -1.98 <= 30 
 x10: -30 <= 0.00 <= 30 
  


    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{250}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{200}\PY{p}{,}\PY{l+m+mf}{0.001} \PY{p}{,}\PY{k+kc}{False}\PY{p}{)} 
         \PY{n}{statistics} \PY{o}{=} \PY{n}{get\PYZus{}stats}\PY{p}{(}\PY{n}{solver\PYZus{}ackley\PYZus{}custom}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{,} \PY{n}{args}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{n}{pprint}\PY{p}{(}\PY{n}{statistics}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\{'Best solution': \{'f': 5.4117166569087765,
                   'x': array([ 0.267664  ,  1.44280275, -0.64901279,  1.25632154,  0.84707397,
       -0.58992425,  0.28989363, -0.87462408, -1.73511192, -0.99452029])\},
 'Mean': 17.879391263858643,
 'Median': 19.950424956466673,
 'Standard deviation': 5.023293120504029,
 'Worst solution': \{'f': 22.283488736223426,
                    'x': array([-28.50118574, -28.50118574, -28.50118574, -28.50118574,
       -28.50118574, -28.50118574, -28.50118574, -28.50118574,
       -28.50118574, -28.50118574])\}\}

    \end{Verbatim}

    \subsection{(1+1)-EE}\label{ee}

    A continación usaremos la EE más simple para intentar resolver la
función de Ackley con 10 variables de decisión.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} \PY{n}{Ackley\PYZus{}basic} \PY{o}{=} \PY{n}{ESBasic}\PY{p}{(}\PY{o}{*}\PY{o}{*}\PY{n}{ackley\PYZus{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{n}{Ackley\PYZus{}basic}\PY{o}{.}\PY{n}{optimize}\PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{additional\PYZus{}arguments} \PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
100\%|██████████| 10000/10000 [00:00<00:00, 11337.41it/s]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{Ackley\PYZus{}basic}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Evolution Strategy search: 
 f(X) = 19.113500402376996 
 X = [-14.04563647  -9.10940732  -6.95817682   8.01075501 -23.01714587
  -7.99060593  -2.84359182 -12.17720417 -25.98627065   0.17446611] 
 Constraints: 
 x1: -30 <= -14.05 <= 30 
 x2: -30 <= -9.11 <= 30 
 x3: -30 <= -6.96 <= 30 
 x4: -30 <= 8.01 <= 30 
 x5: -30 <= -23.02 <= 30 
 x6: -30 <= -7.99 <= 30 
 x7: -30 <= -2.84 <= 30 
 x8: -30 <= -12.18 <= 30 
 x9: -30 <= -25.99 <= 30 
 x10: -30 <= 0.17 <= 30 
  


    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mf}{0.001}\PY{p}{,}\PY{k+kc}{False}\PY{p}{)}
         \PY{n}{statistics} \PY{o}{=} \PY{n}{get\PYZus{}stats}\PY{p}{(}\PY{n}{Ackley\PYZus{}basic}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{,} \PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{additional\PYZus{}arguments} \PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{pprint}\PY{p}{(}\PY{n}{statistics}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\{'Best solution': \{'f': 16.959169469710393,
                   'x': array([  8.9276951 ,  15.93280431,  -1.93419654,  -0.03219489,
         3.96515827,   6.89752938,  -5.06776863, -11.02911313,
        14.8878337 ,   7.03884713])\},
 'Mean': 19.54747426262706,
 'Median': 19.691584669060312,
 'Standard deviation': 0.6647809401288951,
 'Worst solution': \{'f': 20.235327209307368,
                    'x': array([ 2.18718978e+01, -6.09861924e+00, -2.99300634e+01, -8.00091391e+00,
        1.50159338e+01,  2.60925239e+01, -2.93202750e-02, -2.30262787e+01,
        1.83874769e+01,  2.50573755e+01])\}\}

    \end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
